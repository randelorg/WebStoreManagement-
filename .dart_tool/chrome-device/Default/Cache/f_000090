define(['dart_sdk', 'packages/charts_flutter/src/canvas/circle_sector_painter.dart', 'packages/charts_flutter/src/canvas/line_painter.dart', 'packages/charts_flutter/src/canvas/pie_painter.dart', 'packages/charts_flutter/src/canvas/point_painter.dart', 'packages/charts_flutter/src/canvas/polygon_painter.dart', 'packages/charts_common/src/chart/common/canvas_shapes.dart', 'packages/charts_flutter/src/text_element.dart', 'packages/charts_common/src/common/text_element.dart', 'packages/charts_common/src/chart/treemap/treemap_chart.dart', 'packages/charts_common/src/common/color.dart', 'packages/charts_common/src/common/graphics_factory.dart'], (function load__packages__charts_flutter__src__chart_canvas_dart(dart_sdk, packages__charts_flutter__src__canvas__circle_sector_painter$46dart, packages__charts_flutter__src__canvas__line_painter$46dart, packages__charts_flutter__src__canvas__pie_painter$46dart, packages__charts_flutter__src__canvas__point_painter$46dart, packages__charts_flutter__src__canvas__polygon_painter$46dart, packages__charts_common__src__chart__common__canvas_shapes$46dart, packages__charts_flutter__src__text_element$46dart, packages__charts_common__src__common__text_element$46dart, packages__charts_common__src__chart__treemap__treemap_chart$46dart, packages__charts_common__src__common__color$46dart, packages__charts_common__src__common__graphics_factory$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const ui = dart_sdk.ui;
  const _interceptors = dart_sdk._interceptors;
  const math = dart_sdk.math;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const circle_sector_painter = packages__charts_flutter__src__canvas__circle_sector_painter$46dart.src__canvas__circle_sector_painter;
  const line_painter = packages__charts_flutter__src__canvas__line_painter$46dart.src__canvas__line_painter;
  const pie_painter = packages__charts_flutter__src__canvas__pie_painter$46dart.src__canvas__pie_painter;
  const point_painter = packages__charts_flutter__src__canvas__point_painter$46dart.src__canvas__point_painter;
  const polygon_painter = packages__charts_flutter__src__canvas__polygon_painter$46dart.src__canvas__polygon_painter;
  const chart_canvas = packages__charts_common__src__chart__common__canvas_shapes$46dart.src__chart__common__chart_canvas;
  const canvas_shapes = packages__charts_common__src__chart__common__canvas_shapes$46dart.src__chart__common__canvas_shapes;
  const text_element = packages__charts_flutter__src__text_element$46dart.src__text_element;
  const text_element$ = packages__charts_common__src__common__text_element$46dart.src__common__text_element;
  const style_factory = packages__charts_common__src__chart__treemap__treemap_chart$46dart.src__common__style__style_factory;
  const color = packages__charts_common__src__common__color$46dart.src__common__color;
  const graphics_factory = packages__charts_common__src__common__graphics_factory$46dart.src__common__graphics_factory;
  var chart_canvas$ = Object.create(dart.library);
  var $left = dartx.left;
  var $top = dartx.top;
  var $width = dartx.width;
  var $height = dartx.height;
  var $toDouble = dartx.toDouble;
  var $length = dartx.length;
  var $_get = dartx._get;
  var $toInt = dartx.toInt;
  var $ceil = dartx.ceil;
  var $right = dartx.right;
  var $bottom = dartx.bottom;
  var $round = dartx.round;
  dart._checkModuleNullSafetyMode(true);
  var T = {
    JSArrayOfColor: () => (T.JSArrayOfColor = dart.constFn(_interceptors.JSArray$(ui.Color)))(),
    RectangleOfnum: () => (T.RectangleOfnum = dart.constFn(math.Rectangle$(core.num)))(),
    PointOfnum: () => (T.PointOfnum = dart.constFn(math.Point$(core.num)))(),
    JSArrayOfPointOfnum: () => (T.JSArrayOfPointOfnum = dart.constFn(_interceptors.JSArray$(T.PointOfnum())))()
  };
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
    get C0() {
      return C[0] = dart.const({
        __proto__: chart_canvas.FillPatternType.prototype,
        [_name]: "FillPatternType.forwardHatch",
        index: 0
      });
    },
    get C1() {
      return C[1] = dart.const({
        __proto__: chart_canvas.FillPatternType.prototype,
        [_name]: "FillPatternType.solid",
        index: 1
      });
    }
  }, false);
  var C = Array(2).fill(void 0);
  var I = [
    "file:///C:/Users/rende/AppData/Local/Pub/Cache/hosted/pub.dartlang.org/charts_flutter-0.11.0/lib/src/chart_canvas.dart",
    "package:charts_flutter/src/chart_canvas.dart"
  ];
  var canvas$ = dart.privateName(chart_canvas$, "ChartCanvas.canvas");
  var graphicsFactory$ = dart.privateName(chart_canvas$, "ChartCanvas.graphicsFactory");
  var _paint = dart.privateName(chart_canvas$, "_paint");
  var _createHintGradient = dart.privateName(chart_canvas$, "_createHintGradient");
  var _drawForwardHatchPattern = dart.privateName(chart_canvas$, "_drawForwardHatchPattern");
  var _name = dart.privateName(chart_canvas, "_name");
  var _getRect = dart.privateName(chart_canvas$, "_getRect");
  var _getRRect = dart.privateName(chart_canvas$, "_getRRect");
  chart_canvas$.ChartCanvas = class ChartCanvas extends core.Object {
    get canvas() {
      return this[canvas$];
    }
    set canvas(value) {
      super.canvas = value;
    }
    get graphicsFactory() {
      return this[graphicsFactory$];
    }
    set graphicsFactory(value) {
      super.graphicsFactory = value;
    }
    drawCircleSector(center, radius, innerRadius, startAngle, endAngle, opts) {
      let fill = opts && 'fill' in opts ? opts.fill : null;
      let stroke = opts && 'stroke' in opts ? opts.stroke : null;
      let strokeWidthPx = opts && 'strokeWidthPx' in opts ? opts.strokeWidthPx : null;
      circle_sector_painter.CircleSectorPainter.draw({canvas: this.canvas, paint: this[_paint], center: center, radius: radius, innerRadius: innerRadius, startAngle: startAngle, endAngle: endAngle, fill: fill});
    }
    drawLine(opts) {
      let points = opts && 'points' in opts ? opts.points : null;
      let clipBounds = opts && 'clipBounds' in opts ? opts.clipBounds : null;
      let fill = opts && 'fill' in opts ? opts.fill : null;
      let stroke = opts && 'stroke' in opts ? opts.stroke : null;
      let roundEndCaps = opts && 'roundEndCaps' in opts ? opts.roundEndCaps : null;
      let strokeWidthPx = opts && 'strokeWidthPx' in opts ? opts.strokeWidthPx : null;
      let dashPattern = opts && 'dashPattern' in opts ? opts.dashPattern : null;
      line_painter.LinePainter.draw({canvas: this.canvas, paint: this[_paint], points: points, clipBounds: clipBounds, fill: fill, stroke: stroke, roundEndCaps: roundEndCaps, strokeWidthPx: strokeWidthPx, dashPattern: dashPattern});
    }
    drawPie(canvasPie) {
      pie_painter.PiePainter.draw(this.canvas, this[_paint], canvasPie);
    }
    drawPoint(opts) {
      let point = opts && 'point' in opts ? opts.point : null;
      let radius = opts && 'radius' in opts ? opts.radius : null;
      let fill = opts && 'fill' in opts ? opts.fill : null;
      let stroke = opts && 'stroke' in opts ? opts.stroke : null;
      let strokeWidthPx = opts && 'strokeWidthPx' in opts ? opts.strokeWidthPx : null;
      let blendMode = opts && 'blendMode' in opts ? opts.blendMode : null;
      point_painter.PointPainter.draw({canvas: this.canvas, paint: this[_paint], point: point, radius: radius, fill: fill, stroke: stroke, strokeWidthPx: strokeWidthPx});
    }
    drawPolygon(opts) {
      let points = opts && 'points' in opts ? opts.points : null;
      let clipBounds = opts && 'clipBounds' in opts ? opts.clipBounds : null;
      let fill = opts && 'fill' in opts ? opts.fill : null;
      let stroke = opts && 'stroke' in opts ? opts.stroke : null;
      let strokeWidthPx = opts && 'strokeWidthPx' in opts ? opts.strokeWidthPx : null;
      polygon_painter.PolygonPainter.draw({canvas: this.canvas, paint: this[_paint], points: points, clipBounds: clipBounds, fill: fill, stroke: stroke, strokeWidthPx: strokeWidthPx});
    }
    [_createHintGradient](left, top, fill) {
      return ui.Gradient.linear(new ui.Offset.new(left, top), new ui.Offset.new(left, top - 5), T.JSArrayOfColor().of([new ui.Color.fromARGB(fill.a, fill.r, fill.g, fill.b), new ui.Color.fromARGB(0, fill.r, fill.g, fill.b)]));
    }
    drawRect(bounds, opts) {
      let fill = opts && 'fill' in opts ? opts.fill : null;
      let pattern = opts && 'pattern' in opts ? opts.pattern : null;
      let stroke = opts && 'stroke' in opts ? opts.stroke : null;
      let strokeWidthPx = opts && 'strokeWidthPx' in opts ? opts.strokeWidthPx : null;
      let drawAreaBounds = opts && 'drawAreaBounds' in opts ? opts.drawAreaBounds : null;
      let drawStroke = strokeWidthPx != null && dart.notNull(strokeWidthPx) > 0.0 && stroke != null;
      let strokeWidthOffset = drawStroke ? strokeWidthPx : 0;
      let fillRectBounds = new (T.RectangleOfnum()).new(bounds[$left] + dart.nullCheck(strokeWidthOffset) / 2, bounds[$top] + dart.notNull(strokeWidthOffset) / 2, bounds[$width] - dart.notNull(strokeWidthOffset), bounds[$height] - dart.notNull(strokeWidthOffset));
      switch (pattern) {
        case C[0] || CT.C0:
        {
          this[_drawForwardHatchPattern](fillRectBounds, this.canvas, {fill: dart.nullCheck(fill), drawAreaBounds: drawAreaBounds});
          break;
        }
        case C[1] || CT.C1:
        default:
        {
          this[_paint].color = new ui.Color.fromARGB(dart.nullCheck(fill).a, fill.r, fill.g, fill.b);
          this[_paint].style = ui.PaintingStyle.fill;
          if (drawAreaBounds != null && bounds[$top] < drawAreaBounds[$top]) {
            this[_paint].shader = this[_createHintGradient](drawAreaBounds[$left][$toDouble](), drawAreaBounds[$top][$toDouble](), fill);
          }
          this.canvas.drawRect(this[_getRect](fillRectBounds), this[_paint]);
          break;
        }
      }
      if (drawStroke) {
        this[_paint].color = new ui.Color.fromARGB(dart.nullCheck(stroke).a, stroke.r, stroke.g, stroke.b);
        this[_paint].shader = drawAreaBounds != null ? this[_createHintGradient](drawAreaBounds[$left][$toDouble](), drawAreaBounds[$top][$toDouble](), stroke) : null;
        this[_paint].strokeJoin = ui.StrokeJoin.round;
        this[_paint].strokeWidth = dart.nullCheck(strokeWidthPx);
        this[_paint].style = ui.PaintingStyle.stroke;
        this.canvas.drawRect(this[_getRect](bounds), this[_paint]);
      }
      this[_paint].shader = null;
    }
    drawRRect(bounds, opts) {
      let t0, t0$;
      let fill = opts && 'fill' in opts ? opts.fill : null;
      let stroke = opts && 'stroke' in opts ? opts.stroke : null;
      let patternColor = opts && 'patternColor' in opts ? opts.patternColor : null;
      let fillPattern = opts && 'fillPattern' in opts ? opts.fillPattern : null;
      let patternStrokeWidthPx = opts && 'patternStrokeWidthPx' in opts ? opts.patternStrokeWidthPx : null;
      let strokeWidthPx = opts && 'strokeWidthPx' in opts ? opts.strokeWidthPx : null;
      let radius = opts && 'radius' in opts ? opts.radius : null;
      let roundTopLeft = opts && 'roundTopLeft' in opts ? opts.roundTopLeft : false;
      let roundTopRight = opts && 'roundTopRight' in opts ? opts.roundTopRight : false;
      let roundBottomLeft = opts && 'roundBottomLeft' in opts ? opts.roundBottomLeft : false;
      let roundBottomRight = opts && 'roundBottomRight' in opts ? opts.roundBottomRight : false;
      this[_paint].color = new ui.Color.fromARGB(dart.nullCheck(fill).a, fill.r, fill.g, fill.b);
      this[_paint].style = ui.PaintingStyle.fill;
      this.canvas.drawRRect(this[_getRRect](bounds, {radius: (t0$ = (t0 = radius, t0 == null ? null : t0[$toDouble]()), t0$ == null ? 0.0 : t0$), roundTopLeft: roundTopLeft, roundTopRight: roundTopRight, roundBottomLeft: roundBottomLeft, roundBottomRight: roundBottomRight}), this[_paint]);
    }
    drawBarStack(barStack, opts) {
      let t0;
      let drawAreaBounds = opts && 'drawAreaBounds' in opts ? opts.drawAreaBounds : null;
      let roundedCorners = barStack.radius != null && 0 < dart.nullCheck(barStack.radius);
      if (roundedCorners) {
        t0 = this.canvas;
        (() => {
          t0.save();
          t0.clipRRect(this[_getRRect](barStack.fullStackRect, {radius: dart.nullCheck(barStack.radius)[$toDouble](), roundTopLeft: barStack.roundTopLeft, roundTopRight: barStack.roundTopRight, roundBottomLeft: barStack.roundBottomLeft, roundBottomRight: barStack.roundBottomRight}));
          return t0;
        })();
      }
      for (let barIndex = 0; barIndex < barStack.segments[$length]; barIndex = barIndex + 1) {
        let segment = barStack.segments[$_get](barIndex);
        this.drawRect(segment.bounds, {fill: segment.fill, pattern: segment.pattern, stroke: segment.stroke, strokeWidthPx: segment.strokeWidthPx, drawAreaBounds: drawAreaBounds});
      }
      if (roundedCorners) {
        this.canvas.restore();
      }
    }
    drawText(textElement, offsetX, offsetY, opts) {
      let rotation = opts && 'rotation' in opts ? opts.rotation : 0;
      if (!text_element.TextElement.is(textElement)) dart.assertFailed(null, I[0], 271, 12, "textElement is TextElement");
      let flutterTextElement = text_element.TextElement.as(textElement);
      let textDirection = flutterTextElement.textDirection;
      let measurement = flutterTextElement.measurement;
      if (rotation !== 0) {
        if (textDirection === text_element$.TextDirection.rtl) {
          offsetY = offsetY + measurement.horizontalSliceWidth[$toInt]();
        }
        offsetX = offsetX - flutterTextElement.verticalFontShift;
        this.canvas.save();
        this.canvas.translate(offsetX[$toDouble](), offsetY[$toDouble]());
        this.canvas.rotate(rotation);
        dart.nullCheck(textElement.textPainter).paint(this.canvas, new ui.Offset.new(0.0, 0.0));
        this.canvas.restore();
      } else {
        if (textDirection === text_element$.TextDirection.rtl) {
          offsetX = offsetX - measurement.horizontalSliceWidth[$toInt]();
        }
        if (textDirection === text_element$.TextDirection.center) {
          offsetX = offsetX - (measurement.horizontalSliceWidth / 2)[$ceil]();
        }
        offsetY = offsetY - flutterTextElement.verticalFontShift;
        dart.nullCheck(textElement.textPainter).paint(this.canvas, new ui.Offset.new(offsetX[$toDouble](), offsetY[$toDouble]()));
      }
    }
    setClipBounds(clipBounds) {
      let t0;
      t0 = this.canvas;
      (() => {
        t0.save();
        t0.clipRect(this[_getRect](clipBounds));
        return t0;
      })();
    }
    resetClipBounds() {
      this.canvas.restore();
    }
    [_getRect](rectangle) {
      return new ui.Rect.fromLTWH(rectangle[$left][$toDouble](), rectangle[$top][$toDouble](), rectangle[$width][$toDouble](), rectangle[$height][$toDouble]());
    }
    [_getRRect](rectangle, opts) {
      let radius = opts && 'radius' in opts ? opts.radius : 0;
      let roundTopLeft = opts && 'roundTopLeft' in opts ? opts.roundTopLeft : false;
      let roundTopRight = opts && 'roundTopRight' in opts ? opts.roundTopRight : false;
      let roundBottomLeft = opts && 'roundBottomLeft' in opts ? opts.roundBottomLeft : false;
      let roundBottomRight = opts && 'roundBottomRight' in opts ? opts.roundBottomRight : false;
      let cornerRadius = radius === 0 ? ui.Radius.zero : new ui.Radius.circular(radius);
      return new ui.RRect.fromLTRBAndCorners(rectangle[$left][$toDouble](), rectangle[$top][$toDouble](), rectangle[$right][$toDouble](), rectangle[$bottom][$toDouble](), {topLeft: roundTopLeft ? cornerRadius : ui.Radius.zero, topRight: roundTopRight ? cornerRadius : ui.Radius.zero, bottomLeft: roundBottomLeft ? cornerRadius : ui.Radius.zero, bottomRight: roundBottomRight ? cornerRadius : ui.Radius.zero});
    }
    [_drawForwardHatchPattern](bounds, canvas, opts) {
      let background = opts && 'background' in opts ? opts.background : null;
      let fill = opts && 'fill' in opts ? opts.fill : null;
      let fillWidthPx = opts && 'fillWidthPx' in opts ? opts.fillWidthPx : 4;
      let drawAreaBounds = opts && 'drawAreaBounds' in opts ? opts.drawAreaBounds : null;
      background == null ? background = style_factory.StyleFactory.style.white : null;
      fill == null ? fill = style_factory.StyleFactory.style.black : null;
      this[_paint].color = new ui.Color.fromARGB(background.a, background.r, background.g, background.b);
      this[_paint].style = ui.PaintingStyle.fill;
      if (drawAreaBounds != null && bounds[$top] < drawAreaBounds[$top]) {
        this[_paint].shader = this[_createHintGradient](drawAreaBounds[$left][$toDouble](), drawAreaBounds[$top][$toDouble](), background);
      }
      canvas.drawRect(this[_getRect](bounds), this[_paint]);
      let size = math.max(core.num, bounds[$width], bounds[$height]);
      let x0 = bounds[$left] + size + fillWidthPx;
      let x1 = bounds[$left] - fillWidthPx;
      let y0 = bounds[$bottom] - size - fillWidthPx;
      let y1 = bounds[$bottom] + fillWidthPx;
      let offset = 8;
      let isVertical = bounds[$height] >= bounds[$width];
      let smallSide = isVertical ? bounds[$width] : bounds[$height];
      let start = -(smallSide / offset)[$round]() * offset;
      let end = size + offset;
      let lineShader = null;
      if (drawAreaBounds != null && bounds[$top] < drawAreaBounds[$top]) {
        lineShader = this[_createHintGradient](drawAreaBounds[$left][$toDouble](), drawAreaBounds[$top][$toDouble](), fill);
      }
      for (let i = start; i < end; i = i + offset) {
        let modifier = isVertical ? -1 * i : i;
        line_painter.LinePainter.draw({canvas: canvas, paint: this[_paint], points: T.JSArrayOfPointOfnum().of([new (T.PointOfnum()).new(x0 + modifier, y0), new (T.PointOfnum()).new(x1 + modifier, y1)]), stroke: fill, strokeWidthPx: fillWidthPx, shader: lineShader});
      }
    }
    set drawingView(viewName) {
    }
  };
  (chart_canvas$.ChartCanvas.new = function(canvas, graphicsFactory) {
    this[_paint] = ui.Paint.new();
    this[canvas$] = canvas;
    this[graphicsFactory$] = graphicsFactory;
    ;
  }).prototype = chart_canvas$.ChartCanvas.prototype;
  dart.addTypeTests(chart_canvas$.ChartCanvas);
  dart.addTypeCaches(chart_canvas$.ChartCanvas);
  chart_canvas$.ChartCanvas[dart.implements] = () => [chart_canvas.ChartCanvas];
  dart.setMethodSignature(chart_canvas$.ChartCanvas, () => ({
    __proto__: dart.getMethods(chart_canvas$.ChartCanvas.__proto__),
    drawCircleSector: dart.fnType(dart.void, [math.Point$(core.num), core.double, core.double, core.double, core.double], {fill: dart.nullable(color.Color), stroke: dart.nullable(color.Color), strokeWidthPx: dart.nullable(core.double)}, {}),
    drawLine: dart.fnType(dart.void, [], {clipBounds: dart.nullable(math.Rectangle$(core.num)), dashPattern: dart.nullable(core.List$(core.int)), fill: dart.nullable(color.Color), roundEndCaps: dart.nullable(core.bool), stroke: dart.nullable(color.Color), strokeWidthPx: dart.nullable(core.double)}, {points: core.List$(math.Point$(core.num))}),
    drawPie: dart.fnType(dart.void, [canvas_shapes.CanvasPie]),
    drawPoint: dart.fnType(dart.void, [], {blendMode: dart.nullable(chart_canvas.BlendMode), fill: dart.nullable(color.Color), stroke: dart.nullable(color.Color), strokeWidthPx: dart.nullable(core.double)}, {point: math.Point$(core.num), radius: core.double}),
    drawPolygon: dart.fnType(dart.void, [], {clipBounds: dart.nullable(math.Rectangle$(core.num)), fill: dart.nullable(color.Color), stroke: dart.nullable(color.Color), strokeWidthPx: dart.nullable(core.double)}, {points: core.List$(math.Point$(core.num))}),
    [_createHintGradient]: dart.fnType(ui.Gradient, [core.double, core.double, color.Color]),
    drawRect: dart.fnType(dart.void, [math.Rectangle$(core.num)], {drawAreaBounds: dart.nullable(math.Rectangle$(core.num)), fill: dart.nullable(color.Color), pattern: dart.nullable(chart_canvas.FillPatternType), stroke: dart.nullable(color.Color), strokeWidthPx: dart.nullable(core.double)}, {}),
    drawRRect: dart.fnType(dart.void, [math.Rectangle$(core.num)], {fill: dart.nullable(color.Color), fillPattern: dart.nullable(chart_canvas.FillPatternType), patternColor: dart.nullable(color.Color), patternStrokeWidthPx: dart.nullable(core.double), radius: dart.nullable(core.num), roundBottomLeft: core.bool, roundBottomRight: core.bool, roundTopLeft: core.bool, roundTopRight: core.bool, stroke: dart.nullable(color.Color), strokeWidthPx: dart.nullable(core.double)}, {}),
    drawBarStack: dart.fnType(dart.void, [canvas_shapes.CanvasBarStack], {drawAreaBounds: dart.nullable(math.Rectangle$(core.num))}, {}),
    drawText: dart.fnType(dart.void, [text_element$.TextElement, core.int, core.int], {rotation: core.double}, {}),
    setClipBounds: dart.fnType(dart.void, [math.Rectangle$(core.int)]),
    resetClipBounds: dart.fnType(dart.void, []),
    [_getRect]: dart.fnType(ui.Rect, [math.Rectangle$(core.num)]),
    [_getRRect]: dart.fnType(ui.RRect, [math.Rectangle$(core.num)], {radius: core.double, roundBottomLeft: core.bool, roundBottomRight: core.bool, roundTopLeft: core.bool, roundTopRight: core.bool}, {}),
    [_drawForwardHatchPattern]: dart.fnType(dart.dynamic, [math.Rectangle$(core.num), ui.Canvas], {background: dart.nullable(color.Color), drawAreaBounds: dart.nullable(math.Rectangle$(core.num)), fill: dart.nullable(color.Color), fillWidthPx: core.double}, {})
  }));
  dart.setSetterSignature(chart_canvas$.ChartCanvas, () => ({
    __proto__: dart.getSetters(chart_canvas$.ChartCanvas.__proto__),
    drawingView: dart.nullable(core.String)
  }));
  dart.setLibraryUri(chart_canvas$.ChartCanvas, I[1]);
  dart.setFieldSignature(chart_canvas$.ChartCanvas, () => ({
    __proto__: dart.getFields(chart_canvas$.ChartCanvas.__proto__),
    canvas: dart.finalFieldType(ui.Canvas),
    graphicsFactory: dart.finalFieldType(graphics_factory.GraphicsFactory),
    [_paint]: dart.finalFieldType(ui.Paint)
  }));
  dart.defineLazy(chart_canvas$.ChartCanvas, {
    /*chart_canvas$.ChartCanvas.rect_top_gradient_pixels*/get rect_top_gradient_pixels() {
      return 5;
    }
  }, false);
  dart.trackLibraries("packages/charts_flutter/src/chart_canvas.dart", {
    "package:charts_flutter/src/chart_canvas.dart": chart_canvas$
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["chart_canvas.dart"],"names":[],"mappings":"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","file":"../../../../../../../../../../../packages/charts_flutter/src/chart_canvas.dart.lib.js"}');
  // Exports:
  return {
    src__chart_canvas: chart_canvas$
  };
}));

//# sourceMappingURL=chart_canvas.dart.lib.js.map

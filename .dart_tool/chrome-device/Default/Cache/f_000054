<<<<<<< HEAD
define(['dart_sdk', 'packages/flutter/src/foundation/debug.dart', 'packages/collection/src/priority_queue.dart', 'packages/flutter/src/foundation/print.dart', 'packages/flutter/src/scheduler/debug.dart', 'packages/flutter/src/foundation/binding.dart', 'packages/flutter/src/scheduler/priority.dart'], (function load__packages__flutter__src__scheduler__binding_dart(dart_sdk, packages__flutter__src__foundation__debug$46dart, packages__collection__src__priority_queue$46dart, packages__flutter__src__foundation__print$46dart, packages__flutter__src__scheduler__debug$46dart, packages__flutter__src__foundation__binding$46dart, packages__flutter__src__scheduler__priority$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const async = dart_sdk.async;
  const _internal = dart_sdk._internal;
  const developer = dart_sdk.developer;
  const _interceptors = dart_sdk._interceptors;
  const ui = dart_sdk.ui;
  const _js_helper = dart_sdk._js_helper;
  const collection = dart_sdk.collection;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const assertions = packages__flutter__src__foundation__debug$46dart.src__foundation__assertions;
  const diagnostics = packages__flutter__src__foundation__debug$46dart.src__foundation__diagnostics;
  const debug = packages__flutter__src__foundation__debug$46dart.src__foundation__debug;
  const priority_queue = packages__collection__src__priority_queue$46dart.src__priority_queue;
  const print = packages__flutter__src__foundation__print$46dart.src__foundation__print;
  const debug$ = packages__flutter__src__scheduler__debug$46dart.src__scheduler__debug;
  const binding = packages__flutter__src__foundation__binding$46dart.src__foundation__binding;
  const priority$ = packages__flutter__src__scheduler__priority$46dart.src__scheduler__priority;
  var binding$ = Object.create(dart.library);
  var $add = dartx.add;
  var $length = dartx.length;
  var $contains = dartx.contains;
  var $remove = dartx.remove;
  var $isEmpty = dartx.isEmpty;
  var $compareTo = dartx.compareTo;
  var $_set = dartx._set;
  var $keys = dartx.keys;
  var $_get = dartx._get;
  var $trimRight = dartx.trimRight;
  var $split = dartx.split;
  var $join = dartx.join;
  var $round = dartx.round;
  var $toString = dartx.toString;
  var $padRight = dartx.padRight;
  var $padLeft = dartx.padLeft;
  var $forEach = dartx.forEach;
  var $clear = dartx.clear;
  var $times = dartx['*'];
  dart._checkModuleNullSafetyMode(true);
  var T$ = {
    VoidTobool: () => (T$.VoidTobool = dart.constFn(dart.fnType(core.bool, [])))(),
    VoidToNull: () => (T$.VoidToNull = dart.constFn(dart.fnType(core.Null, [])))(),
    JSArrayOfDiagnosticsNode: () => (T$.JSArrayOfDiagnosticsNode = dart.constFn(_interceptors.JSArray$(diagnostics.DiagnosticsNode)))(),
    ListOfFrameTiming: () => (T$.ListOfFrameTiming = dart.constFn(core.List$(ui.FrameTiming)))(),
    ListOfFrameTimingTovoid: () => (T$.ListOfFrameTimingTovoid = dart.constFn(dart.fnType(dart.void, [T$.ListOfFrameTiming()])))(),
    JSArrayOfListOfFrameTimingTovoid: () => (T$.JSArrayOfListOfFrameTimingTovoid = dart.constFn(_interceptors.JSArray$(T$.ListOfFrameTimingTovoid())))(),
    __Tobool: () => (T$.__Tobool = dart.constFn(dart.fnType(core.bool, [], {}, {priority: core.int, scheduler: binding$.SchedulerBinding})))(),
    HeapPriorityQueueOf_TaskEntry: () => (T$.HeapPriorityQueueOf_TaskEntry = dart.constFn(priority_queue.HeapPriorityQueue$(binding$._TaskEntry)))(),
    _TaskEntryAnd_TaskEntryToint: () => (T$._TaskEntryAnd_TaskEntryToint = dart.constFn(dart.fnType(core.int, [binding$._TaskEntry, binding$._TaskEntry])))(),
    IdentityMapOfint$_FrameCallbackEntry: () => (T$.IdentityMapOfint$_FrameCallbackEntry = dart.constFn(_js_helper.IdentityMap$(core.int, binding$._FrameCallbackEntry)))(),
    _IdentityHashSetOfint: () => (T$._IdentityHashSetOfint = dart.constFn(collection._IdentityHashSet$(core.int)))(),
    DurationTovoid: () => (T$.DurationTovoid = dart.constFn(dart.fnType(dart.void, [core.Duration])))(),
    JSArrayOfDurationTovoid: () => (T$.JSArrayOfDurationTovoid = dart.constFn(_interceptors.JSArray$(T$.DurationTovoid())))(),
    ListOfListOfFrameTimingTovoid: () => (T$.ListOfListOfFrameTimingTovoid = dart.constFn(core.List$(T$.ListOfFrameTimingTovoid())))(),
    DiagnosticsPropertyOfListOfFrameTimingTovoid: () => (T$.DiagnosticsPropertyOfListOfFrameTimingTovoid = dart.constFn(diagnostics.DiagnosticsProperty$(T$.ListOfFrameTimingTovoid())))(),
    SyncIterableOfDiagnosticsNode: () => (T$.SyncIterableOfDiagnosticsNode = dart.constFn(_js_helper.SyncIterable$(diagnostics.DiagnosticsNode)))(),
    IterableOfDiagnosticsNode: () => (T$.IterableOfDiagnosticsNode = dart.constFn(core.Iterable$(diagnostics.DiagnosticsNode)))(),
    VoidToIterableOfDiagnosticsNode: () => (T$.VoidToIterableOfDiagnosticsNode = dart.constFn(dart.fnType(T$.IterableOfDiagnosticsNode(), [])))(),
    FutureOfdouble: () => (T$.FutureOfdouble = dart.constFn(async.Future$(core.double)))(),
    VoidToFutureOfdouble: () => (T$.VoidToFutureOfdouble = dart.constFn(dart.fnType(T$.FutureOfdouble(), [])))(),
    FutureOfvoid: () => (T$.FutureOfvoid = dart.constFn(async.Future$(dart.void)))(),
    doubleToFutureOfvoid: () => (T$.doubleToFutureOfvoid = dart.constFn(dart.fnType(T$.FutureOfvoid(), [core.double])))(),
    LinkedHashMapOfint$_FrameCallbackEntry: () => (T$.LinkedHashMapOfint$_FrameCallbackEntry = dart.constFn(collection.LinkedHashMap$(core.int, binding$._FrameCallbackEntry)))(),
    CompleterOfvoid: () => (T$.CompleterOfvoid = dart.constFn(async.Completer$(dart.void)))(),
    VoidTovoid: () => (T$.VoidTovoid = dart.constFn(dart.fnType(dart.void, [])))(),
    VoidToFutureOfvoid: () => (T$.VoidToFutureOfvoid = dart.constFn(dart.fnType(T$.FutureOfvoid(), [])))(),
    intAnd_FrameCallbackEntryTovoid: () => (T$.intAnd_FrameCallbackEntryTovoid = dart.constFn(dart.fnType(dart.void, [core.int, binding$._FrameCallbackEntry])))(),
    ListOfDurationTovoid: () => (T$.ListOfDurationTovoid = dart.constFn(core.List$(T$.DurationTovoid())))(),
    IdentityMapOfString$dynamic: () => (T$.IdentityMapOfString$dynamic = dart.constFn(_js_helper.IdentityMap$(core.String, dart.dynamic)))()
=======
define(['dart_sdk', 'packages/flutter/src/foundation/debug.dart', 'packages/flutter/src/scheduler/binding.dart'], (function load__packages__flutter__src__painting__image_stream_dart(dart_sdk, packages__flutter__src__foundation__debug$46dart, packages__flutter__src__scheduler__binding$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const ui = dart_sdk.ui;
  const _interceptors = dart_sdk._interceptors;
  const _internal = dart_sdk._internal;
  const async = dart_sdk.async;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const debug = packages__flutter__src__foundation__debug$46dart.src__foundation__debug;
  const diagnostics = packages__flutter__src__foundation__debug$46dart.src__foundation__diagnostics;
  const assertions = packages__flutter__src__foundation__debug$46dart.src__foundation__assertions;
  const binding = packages__flutter__src__scheduler__binding$46dart.src__scheduler__binding;
  var image_stream = Object.create(dart.library);
  var $length = dartx.length;
  var $runtimeType = dartx.runtimeType;
  var $_equals = dartx._equals;
  var $forEach = dartx.forEach;
  var $add = dartx.add;
  var $_get = dartx._get;
  var $removeAt = dartx.removeAt;
  var $isNotEmpty = dartx.isNotEmpty;
  var $isEmpty = dartx.isEmpty;
  var $toList = dartx.toList;
  var $clear = dartx.clear;
  var $remove = dartx.remove;
  var $map = dartx.map;
  var $whereType = dartx.whereType;
  var $truncate = dartx.truncate;
  dart._checkModuleNullSafetyMode(true);
  var T = {
    JSArrayOfImageStreamListener: () => (T.JSArrayOfImageStreamListener = dart.constFn(_interceptors.JSArray$(image_stream.ImageStreamListener)))(),
    ObjectFlagPropertyOfImageStreamCompleter: () => (T.ObjectFlagPropertyOfImageStreamCompleter = dart.constFn(diagnostics.ObjectFlagProperty$(image_stream.ImageStreamCompleter)))(),
    ListOfImageStreamListener: () => (T.ListOfImageStreamListener = dart.constFn(core.List$(image_stream.ImageStreamListener)))(),
    ObjectFlagPropertyOfListOfImageStreamListener: () => (T.ObjectFlagPropertyOfListOfImageStreamListener = dart.constFn(diagnostics.ObjectFlagProperty$(T.ListOfImageStreamListener())))(),
    VoidTovoid: () => (T.VoidTovoid = dart.constFn(dart.fnType(dart.void, [])))(),
    JSArrayOfVoidTovoid: () => (T.JSArrayOfVoidTovoid = dart.constFn(_interceptors.JSArray$(T.VoidTovoid())))(),
    StackTraceN: () => (T.StackTraceN = dart.constFn(dart.nullable(core.StackTrace)))(),
    ObjectAndStackTraceNTovoid: () => (T.ObjectAndStackTraceNTovoid = dart.constFn(dart.fnType(dart.void, [core.Object, T.StackTraceN()])))(),
    ObjectAndStackTraceNToNvoid: () => (T.ObjectAndStackTraceNToNvoid = dart.constFn(dart.nullable(T.ObjectAndStackTraceNTovoid())))(),
    ImageStreamListenerToFn: () => (T.ImageStreamListenerToFn = dart.constFn(dart.fnType(T.ObjectAndStackTraceNToNvoid(), [image_stream.ImageStreamListener])))(),
    ImageChunkEventTovoid: () => (T.ImageChunkEventTovoid = dart.constFn(dart.fnType(dart.void, [image_stream.ImageChunkEvent])))(),
    ImageChunkEventToNvoid: () => (T.ImageChunkEventToNvoid = dart.constFn(dart.nullable(T.ImageChunkEventTovoid())))(),
    ImageStreamListenerToFn$1: () => (T.ImageStreamListenerToFn$1 = dart.constFn(dart.fnType(T.ImageChunkEventToNvoid(), [image_stream.ImageStreamListener])))(),
    DiagnosticsPropertyOfImageInfo: () => (T.DiagnosticsPropertyOfImageInfo = dart.constFn(diagnostics.DiagnosticsProperty$(image_stream.ImageInfo)))(),
    ObjectAndStackTraceToNull: () => (T.ObjectAndStackTraceToNull = dart.constFn(dart.fnType(core.Null, [core.Object, core.StackTrace])))()
>>>>>>> feature-b
  };
  const CT = Object.create({
    _: () => (C, CT)
  });
<<<<<<< HEAD
  dart.defineLazy(CT, {
    get C0() {
      return C[0] = dart.const({
        __proto__: binding$.SchedulerPhase.prototype,
        [_name$]: "SchedulerPhase.idle",
        index: 0
      });
    },
    get C1() {
      return C[1] = dart.const({
        __proto__: binding$.SchedulerPhase.prototype,
        [_name$]: "SchedulerPhase.transientCallbacks",
        index: 1
      });
    },
    get C2() {
      return C[2] = dart.const({
        __proto__: binding$.SchedulerPhase.prototype,
        [_name$]: "SchedulerPhase.midFrameMicrotasks",
        index: 2
      });
    },
    get C3() {
      return C[3] = dart.const({
        __proto__: binding$.SchedulerPhase.prototype,
        [_name$]: "SchedulerPhase.persistentCallbacks",
        index: 3
      });
    },
    get C4() {
      return C[4] = dart.const({
        __proto__: binding$.SchedulerPhase.prototype,
        [_name$]: "SchedulerPhase.postFrameCallbacks",
        index: 4
      });
    },
    get C5() {
      return C[5] = dart.constList([C[0] || CT.C0, C[1] || CT.C1, C[2] || CT.C2, C[3] || CT.C3, C[4] || CT.C4], binding$.SchedulerPhase);
    },
    get C6() {
      return C[6] = dart.fn(binding$.defaultSchedulingStrategy, T$.__Tobool());
    },
    get C7() {
      return C[7] = dart.fn(binding$.SchedulerBinding._taskSorter, T$._TaskEntryAnd_TaskEntryToint());
    },
    get C8() {
      return C[8] = dart.const({
        __proto__: ui.AppLifecycleState.prototype,
        [_name]: "AppLifecycleState.resumed",
        index: 0
      });
    },
    get C9() {
      return C[9] = dart.const({
        __proto__: ui.AppLifecycleState.prototype,
        [_name]: "AppLifecycleState.inactive",
        index: 1
      });
    },
    get C10() {
      return C[10] = dart.const({
        __proto__: ui.AppLifecycleState.prototype,
        [_name]: "AppLifecycleState.paused",
        index: 2
      });
    },
    get C11() {
      return C[11] = dart.const({
        __proto__: ui.AppLifecycleState.prototype,
        [_name]: "AppLifecycleState.detached",
        index: 3
      });
    }
  }, false);
  var C = Array(12).fill(void 0);
  var I = [
    "file:///C:/flutter/packages/flutter/lib/src/scheduler/binding.dart",
    "package:flutter/src/scheduler/binding.dart"
  ];
  var ___TaskEntry_debugStack = dart.privateName(binding$, "_#_TaskEntry#debugStack");
  const _is__TaskEntry_default = Symbol('_is__TaskEntry_default');
  binding$._TaskEntry$ = dart.generic(T => {
    var CompleterOfT = () => (CompleterOfT = dart.constFn(async.Completer$(T)))();
    class _TaskEntry extends core.Object {
      get debugStack() {
        let t0;
        t0 = this[___TaskEntry_debugStack];
        return t0 == null ? dart.throw(new _internal.LateError.fieldNI("debugStack")) : t0;
      }
      set debugStack(t0) {
        this[___TaskEntry_debugStack] = t0;
      }
      run() {
        let t1;
        if (!false) {
          developer.Timeline.timeSync(core.Null, (t1 = this.debugLabel, t1 == null ? "Scheduled Task" : t1), dart.fn(() => {
            this.completer.complete(this.task());
          }, T$.VoidToNull()), {flow: this.flow != null ? developer.Flow.step(dart.nullCheck(this.flow).id) : null});
        } else {
          this.completer.complete(this.task());
        }
      }
    }
    (_TaskEntry.new = function(task, priority, debugLabel, flow) {
      this[___TaskEntry_debugStack] = null;
      this.completer = CompleterOfT().new();
      this.task = task;
      this.priority = priority;
      this.debugLabel = debugLabel;
      this.flow = flow;
      if (!dart.fn(() => {
        this.debugStack = core.StackTrace.current;
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 62, 12, "() {\r\n      debugStack = StackTrace.current;\r\n      return true;\r\n    }()");
    }).prototype = _TaskEntry.prototype;
    dart.addTypeTests(_TaskEntry);
    _TaskEntry.prototype[_is__TaskEntry_default] = true;
    dart.addTypeCaches(_TaskEntry);
    dart.setMethodSignature(_TaskEntry, () => ({
      __proto__: dart.getMethods(_TaskEntry.__proto__),
      run: dart.fnType(dart.void, [])
    }));
    dart.setGetterSignature(_TaskEntry, () => ({
      __proto__: dart.getGetters(_TaskEntry.__proto__),
      debugStack: core.StackTrace
    }));
    dart.setSetterSignature(_TaskEntry, () => ({
      __proto__: dart.getSetters(_TaskEntry.__proto__),
      debugStack: core.StackTrace
    }));
    dart.setLibraryUri(_TaskEntry, I[1]);
    dart.setFieldSignature(_TaskEntry, () => ({
      __proto__: dart.getFields(_TaskEntry.__proto__),
      task: dart.finalFieldType(dart.fnType(T, [])),
      priority: dart.finalFieldType(core.int),
      debugLabel: dart.finalFieldType(dart.nullable(core.String)),
      flow: dart.finalFieldType(dart.nullable(developer.Flow)),
      [___TaskEntry_debugStack]: dart.fieldType(dart.nullable(core.StackTrace)),
      completer: dart.finalFieldType(async.Completer$(T))
    }));
    return _TaskEntry;
  });
  binding$._TaskEntry = binding$._TaskEntry$();
  dart.addTypeTests(binding$._TaskEntry, _is__TaskEntry_default);
  binding$._FrameCallbackEntry = class _FrameCallbackEntry extends core.Object {};
  (binding$._FrameCallbackEntry.new = function(callback, opts) {
    let rescheduling = opts && 'rescheduling' in opts ? opts.rescheduling : false;
    this.debugStack = null;
    this.callback = callback;
    if (!dart.fn(() => {
      if (rescheduling) {
        if (!dart.fn(() => {
          if (binding$._FrameCallbackEntry.debugCurrentCallbackStack == null) {
            dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("scheduleFrameCallback called with rescheduling true, but no callback is in scope."), new assertions.ErrorDescription.new("The \"rescheduling\" argument should only be set to true if the " + "callback is being reregistered from within the callback itself, " + "and only then if the callback itself is entirely synchronous."), new assertions.ErrorHint.new("If this is the initial registration of the callback, or if the " + "callback is asynchronous, then do not use the \"rescheduling\" " + "argument.")])));
          }
          return true;
        }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 94, 16, "() {\r\n          if (debugCurrentCallbackStack == null) {\r\n            throw FlutterError.fromParts(<DiagnosticsNode>[\r\n              ErrorSummary('scheduleFrameCallback called with rescheduling true, but no callback is in scope.'),\r\n              ErrorDescription(\r\n                'The \"rescheduling\" argument should only be set to true if the '\r\n                'callback is being reregistered from within the callback itself, '\r\n                'and only then if the callback itself is entirely synchronous.',\r\n              ),\r\n              ErrorHint(\r\n                'If this is the initial registration of the callback, or if the '\r\n                'callback is asynchronous, then do not use the \"rescheduling\" '\r\n                'argument.',\r\n              ),\r\n            ]);\r\n          }\r\n          return true;\r\n        }()");
        this.debugStack = binding$._FrameCallbackEntry.debugCurrentCallbackStack;
      } else {
        this.debugStack = core.StackTrace.current;
      }
      return true;
    }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 92, 12, "() {\r\n      if (rescheduling) {\r\n        assert(() {\r\n          if (debugCurrentCallbackStack == null) {\r\n            throw FlutterError.fromParts(<DiagnosticsNode>[\r\n              ErrorSummary('scheduleFrameCallback called with rescheduling true, but no callback is in scope.'),\r\n              ErrorDescription(\r\n                'The \"rescheduling\" argument should only be set to true if the '\r\n                'callback is being reregistered from within the callback itself, '\r\n                'and only then if the callback itself is entirely synchronous.',\r\n              ),\r\n              ErrorHint(\r\n                'If this is the initial registration of the callback, or if the '\r\n                'callback is asynchronous, then do not use the \"rescheduling\" '\r\n                'argument.',\r\n              ),\r\n            ]);\r\n          }\r\n          return true;\r\n        }());\r\n        debugStack = debugCurrentCallbackStack;\r\n      } else {\r\n        // TODO(ianh): trim the frames from this library, so that the call to scheduleFrameCallback is the top one\r\n        debugStack = StackTrace.current;\r\n      }\r\n      return true;\r\n    }()");
  }).prototype = binding$._FrameCallbackEntry.prototype;
  dart.addTypeTests(binding$._FrameCallbackEntry);
  dart.addTypeCaches(binding$._FrameCallbackEntry);
  dart.setLibraryUri(binding$._FrameCallbackEntry, I[1]);
  dart.setFieldSignature(binding$._FrameCallbackEntry, () => ({
    __proto__: dart.getFields(binding$._FrameCallbackEntry.__proto__),
    callback: dart.finalFieldType(dart.fnType(dart.void, [core.Duration])),
    debugStack: dart.fieldType(dart.nullable(core.StackTrace))
  }));
  dart.defineLazy(binding$._FrameCallbackEntry, {
    /*binding$._FrameCallbackEntry.debugCurrentCallbackStack*/get debugCurrentCallbackStack() {
      return null;
    },
    set debugCurrentCallbackStack(_) {}
  }, false);
  var _name$ = dart.privateName(binding$, "_name");
  binding$.SchedulerPhase = class SchedulerPhase extends core.Object {
    toString() {
      return this[_name$];
    }
  };
  (binding$.SchedulerPhase.new = function(index, _name) {
    this.index = index;
    this[_name$] = _name;
    ;
  }).prototype = binding$.SchedulerPhase.prototype;
  dart.addTypeTests(binding$.SchedulerPhase);
  dart.addTypeCaches(binding$.SchedulerPhase);
  dart.setLibraryUri(binding$.SchedulerPhase, I[1]);
  dart.setFieldSignature(binding$.SchedulerPhase, () => ({
    __proto__: dart.getFields(binding$.SchedulerPhase.__proto__),
    index: dart.finalFieldType(core.int),
    [_name$]: dart.finalFieldType(core.String)
  }));
  dart.defineExtensionMethods(binding$.SchedulerPhase, ['toString']);
  binding$.SchedulerPhase.idle = C[0] || CT.C0;
  binding$.SchedulerPhase.transientCallbacks = C[1] || CT.C1;
  binding$.SchedulerPhase.midFrameMicrotasks = C[2] || CT.C2;
  binding$.SchedulerPhase.persistentCallbacks = C[3] || CT.C3;
  binding$.SchedulerPhase.postFrameCallbacks = C[4] || CT.C4;
  binding$.SchedulerPhase.values = C[5] || CT.C5;
  var schedulingStrategy = dart.privateName(binding$, "SchedulerBinding.schedulingStrategy");
  var _timingsCallbacks = dart.privateName(binding$, "_timingsCallbacks");
  var _lifecycleState = dart.privateName(binding$, "_lifecycleState");
  var _taskQueue = dart.privateName(binding$, "_taskQueue");
  var _hasRequestedAnEventLoopCallback = dart.privateName(binding$, "_hasRequestedAnEventLoopCallback");
  var _nextFrameCallbackId = dart.privateName(binding$, "_nextFrameCallbackId");
  var _transientCallbacks = dart.privateName(binding$, "_transientCallbacks");
  var _removedIds = dart.privateName(binding$, "_removedIds");
  var _persistentCallbacks = dart.privateName(binding$, "_persistentCallbacks");
  var _postFrameCallbacks = dart.privateName(binding$, "_postFrameCallbacks");
  var _nextFrameCompleter = dart.privateName(binding$, "_nextFrameCompleter");
  var _hasScheduledFrame = dart.privateName(binding$, "_hasScheduledFrame");
  var _schedulerPhase = dart.privateName(binding$, "_schedulerPhase");
  var _framesEnabled = dart.privateName(binding$, "_framesEnabled");
  var _warmUpFrame = dart.privateName(binding$, "_warmUpFrame");
  var _firstRawTimeStampInEpoch = dart.privateName(binding$, "_firstRawTimeStampInEpoch");
  var _epochStart = dart.privateName(binding$, "_epochStart");
  var _lastRawTimeStamp = dart.privateName(binding$, "_lastRawTimeStamp");
  var _currentFrameTimeStamp = dart.privateName(binding$, "_currentFrameTimeStamp");
  var _debugFrameNumber = dart.privateName(binding$, "_debugFrameNumber");
  var _debugBanner = dart.privateName(binding$, "_debugBanner");
  var _rescheduleAfterWarmUpFrame = dart.privateName(binding$, "_rescheduleAfterWarmUpFrame");
  var _profileFramePostEvent = dart.privateName(binding$, "_profileFramePostEvent");
  var _executeTimingsCallbacks = dart.privateName(binding$, "_executeTimingsCallbacks");
  var _setFramesEnabledState = dart.privateName(binding$, "_setFramesEnabledState");
  var _name = dart.privateName(ui, "_name");
  var _ensureEventLoopCallback = dart.privateName(binding$, "_ensureEventLoopCallback");
  var _runTasks = dart.privateName(binding$, "_runTasks");
  var _handleBeginFrame = dart.privateName(binding$, "_handleBeginFrame");
  var _handleDrawFrame = dart.privateName(binding$, "_handleDrawFrame");
  var _adjustForEpoch = dart.privateName(binding$, "_adjustForEpoch");
  var _invokeFrameCallback = dart.privateName(binding$, "_invokeFrameCallback");
  binding$.SchedulerBinding = class SchedulerBinding extends binding.BindingBase {
    static get instance() {
      return binding$.SchedulerBinding._instance;
    }
    static _taskSorter(e1, e2) {
      return -e1.priority[$compareTo](e2.priority);
    }
    static debugPrintTransientCallbackRegistrationStack() {
      if (!dart.fn(() => {
        if (binding$._FrameCallbackEntry.debugCurrentCallbackStack != null) {
          print.debugPrint("When the current transient callback was registered, this was the stack:");
          print.debugPrint(assertions.FlutterError.defaultStackFilter(assertions.FlutterError.demangleStackTrace(dart.nullCheck(binding$._FrameCallbackEntry.debugCurrentCallbackStack)).toString()[$trimRight]()[$split]("\n"))[$join]("\n"));
        } else {
          print.debugPrint("No transient callback is currently executing.");
        }
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 616, 12, "() {\r\n      if (_FrameCallbackEntry.debugCurrentCallbackStack != null) {\r\n        debugPrint('When the current transient callback was registered, this was the stack:');\r\n        debugPrint(\r\n          FlutterError.defaultStackFilter(\r\n            FlutterError.demangleStackTrace(\r\n              _FrameCallbackEntry.debugCurrentCallbackStack!,\r\n            ).toString().trimRight().split('\\n'),\r\n          ).join('\\n'),\r\n        );\r\n      } else {\r\n        debugPrint('No transient callback is currently executing.');\r\n      }\r\n      return true;\r\n    }()");
    }
    static _debugDescribeTimeStamp(timeStamp, buffer) {
      if (timeStamp.inDays > 0) buffer.write(dart.str(timeStamp.inDays) + "d ");
      if (timeStamp.inHours > 0) buffer.write(dart.str(timeStamp.inHours - timeStamp.inDays * 24) + "h ");
      if (timeStamp.inMinutes > 0) buffer.write(dart.str(timeStamp.inMinutes - timeStamp.inHours * 60) + "m ");
      if (timeStamp.inSeconds > 0) buffer.write(dart.str(timeStamp.inSeconds - timeStamp.inMinutes * 60) + "s ");
      buffer.write(dart.str(timeStamp.inMilliseconds - timeStamp.inSeconds * 1000));
      let microseconds = timeStamp.inMicroseconds - timeStamp.inMilliseconds * 1000;
      if (microseconds > 0) buffer.write("." + microseconds[$toString]()[$padLeft](3, "0"));
      buffer.write("ms");
    }
  };
  binding$.SchedulerBinding[dart.mixinOn] = BindingBase => class SchedulerBinding extends BindingBase {
    get schedulingStrategy() {
      return this[schedulingStrategy];
    }
    set schedulingStrategy(value) {
      this[schedulingStrategy] = value;
    }
    initInstances() {
      super.initInstances();
      binding$.SchedulerBinding._instance = this;
      if (!false) {
        let frameNumber = 0;
        this.addTimingsCallback(dart.fn(timings => {
          for (let frameTiming of timings) {
            frameNumber = frameNumber + 1;
            this[_profileFramePostEvent](frameNumber, frameTiming);
          }
        }, T$.ListOfFrameTimingTovoid()));
      }
    }
    addTimingsCallback(callback) {
      this[_timingsCallbacks][$add](callback);
      if (this[_timingsCallbacks][$length] === 1) {
        if (!(this.window.onReportTimings == null)) dart.assertFailed(null, I[0], 268, 14, "window.onReportTimings == null");
        this.window.onReportTimings = dart.bind(this, _executeTimingsCallbacks);
      }
      if (!dart.equals(this.window.onReportTimings, dart.bind(this, _executeTimingsCallbacks))) dart.assertFailed(null, I[0], 271, 12, "window.onReportTimings == _executeTimingsCallbacks");
    }
    removeTimingsCallback(callback) {
      if (!this[_timingsCallbacks][$contains](callback)) dart.assertFailed(null, I[0], 276, 12, "_timingsCallbacks.contains(callback)");
      this[_timingsCallbacks][$remove](callback);
      if (this[_timingsCallbacks][$isEmpty]) {
        this.window.onReportTimings = null;
      }
    }
    [_executeTimingsCallbacks](timings) {
      let clonedCallbacks = T$.ListOfListOfFrameTimingTovoid().from(this[_timingsCallbacks]);
      for (let callback of clonedCallbacks) {
        try {
          if (this[_timingsCallbacks][$contains](callback)) {
            callback(timings);
          }
=======
  var I = [
    "file:///C:/flutter/packages/flutter/lib/src/painting/image_stream.dart",
    "package:flutter/src/painting/image_stream.dart"
  ];
  var image$ = dart.privateName(image_stream, "ImageInfo.image");
  var scale$ = dart.privateName(image_stream, "ImageInfo.scale");
  var debugLabel$ = dart.privateName(image_stream, "ImageInfo.debugLabel");
  image_stream.ImageInfo = class ImageInfo extends core.Object {
    get image() {
      return this[image$];
    }
    set image(value) {
      super.image = value;
    }
    get scale() {
      return this[scale$];
    }
    set scale(value) {
      super.scale = value;
    }
    get debugLabel() {
      return this[debugLabel$];
    }
    set debugLabel(value) {
      super.debugLabel = value;
    }
    clone() {
      return new image_stream.ImageInfo.new({image: this.image.clone(), scale: this.scale, debugLabel: this.debugLabel});
    }
    isCloneOf(other) {
      return other.image.isCloneOf(this.image) && this.scale === this.scale && other.debugLabel == this.debugLabel;
    }
    dispose() {
      let t0, t0$;
      if (!(dart.notNull((t0$ = (t0 = this.image.debugGetOpenHandleStackTraces(), t0 == null ? null : t0[$length]), t0$ == null ? 1 : t0$)) > 0)) dart.assertFailed(null, I[0], 122, 12, "(image.debugGetOpenHandleStackTraces()?.length ?? 1) > 0");
      this.image.dispose();
    }
    toString() {
      return (this.debugLabel != null ? dart.str(this.debugLabel) + " " : "") + dart.str(this.image) + " @ " + debug.debugFormatDouble(this.scale) + "x";
    }
    get hashCode() {
      return ui.hashValues(this.image, this.scale, this.debugLabel);
    }
    _equals(other) {
      if (other == null) return false;
      if (!other[$runtimeType]._equals(this[$runtimeType])) return false;
      return image_stream.ImageInfo.is(other) && other.image[$_equals](this.image) && other.scale === this.scale && other.debugLabel == this.debugLabel;
    }
  };
  (image_stream.ImageInfo.new = function(opts) {
    let image = opts && 'image' in opts ? opts.image : null;
    let scale = opts && 'scale' in opts ? opts.scale : 1;
    let debugLabel = opts && 'debugLabel' in opts ? opts.debugLabel : null;
    this[image$] = image;
    this[scale$] = scale;
    this[debugLabel$] = debugLabel;
    if (!(image !== null)) dart.assertFailed(null, I[0], 28, 14, "image != null");
    if (!(scale !== null)) dart.assertFailed(null, I[0], 29, 14, "scale != null");
    ;
  }).prototype = image_stream.ImageInfo.prototype;
  dart.addTypeTests(image_stream.ImageInfo);
  dart.addTypeCaches(image_stream.ImageInfo);
  dart.setMethodSignature(image_stream.ImageInfo, () => ({
    __proto__: dart.getMethods(image_stream.ImageInfo.__proto__),
    clone: dart.fnType(image_stream.ImageInfo, []),
    isCloneOf: dart.fnType(core.bool, [image_stream.ImageInfo]),
    dispose: dart.fnType(dart.void, [])
  }));
  dart.setLibraryUri(image_stream.ImageInfo, I[1]);
  dart.setFieldSignature(image_stream.ImageInfo, () => ({
    __proto__: dart.getFields(image_stream.ImageInfo.__proto__),
    image: dart.finalFieldType(ui.Image),
    scale: dart.finalFieldType(core.double),
    debugLabel: dart.finalFieldType(dart.nullable(core.String))
  }));
  dart.defineExtensionMethods(image_stream.ImageInfo, ['toString', '_equals']);
  dart.defineExtensionAccessors(image_stream.ImageInfo, ['hashCode']);
  var onImage$ = dart.privateName(image_stream, "ImageStreamListener.onImage");
  var onChunk$ = dart.privateName(image_stream, "ImageStreamListener.onChunk");
  var onError$ = dart.privateName(image_stream, "ImageStreamListener.onError");
  image_stream.ImageStreamListener = class ImageStreamListener extends core.Object {
    get onImage() {
      return this[onImage$];
    }
    set onImage(value) {
      super.onImage = value;
    }
    get onChunk() {
      return this[onChunk$];
    }
    set onChunk(value) {
      super.onChunk = value;
    }
    get onError() {
      return this[onError$];
    }
    set onError(value) {
      super.onError = value;
    }
    get hashCode() {
      return ui.hashValues(this.onImage, this.onChunk, this.onError);
    }
    _equals(other) {
      if (other == null) return false;
      if (!other[$runtimeType]._equals(this[$runtimeType])) return false;
      return image_stream.ImageStreamListener.is(other) && other.onImage[$_equals](this.onImage) && dart.equals(other.onChunk, this.onChunk) && dart.equals(other.onError, this.onError);
    }
  };
  (image_stream.ImageStreamListener.new = function(onImage, opts) {
    let onChunk = opts && 'onChunk' in opts ? opts.onChunk : null;
    let onError = opts && 'onError' in opts ? opts.onError : null;
    this[onImage$] = onImage;
    this[onChunk$] = onChunk;
    this[onError$] = onError;
    if (!(onImage !== null)) dart.assertFailed(null, I[0], 162, 15, "onImage != null");
    ;
  }).prototype = image_stream.ImageStreamListener.prototype;
  dart.addTypeTests(image_stream.ImageStreamListener);
  dart.addTypeCaches(image_stream.ImageStreamListener);
  dart.setLibraryUri(image_stream.ImageStreamListener, I[1]);
  dart.setFieldSignature(image_stream.ImageStreamListener, () => ({
    __proto__: dart.getFields(image_stream.ImageStreamListener.__proto__),
    onImage: dart.finalFieldType(dart.fnType(dart.void, [image_stream.ImageInfo, core.bool])),
    onChunk: dart.finalFieldType(dart.nullable(dart.fnType(dart.void, [image_stream.ImageChunkEvent]))),
    onError: dart.finalFieldType(dart.nullable(dart.fnType(dart.void, [core.Object, dart.nullable(core.StackTrace)])))
  }));
  dart.defineExtensionMethods(image_stream.ImageStreamListener, ['_equals']);
  dart.defineExtensionAccessors(image_stream.ImageStreamListener, ['hashCode']);
  var cumulativeBytesLoaded$ = dart.privateName(image_stream, "ImageChunkEvent.cumulativeBytesLoaded");
  var expectedTotalBytes$ = dart.privateName(image_stream, "ImageChunkEvent.expectedTotalBytes");
  const Object_Diagnosticable$36 = class Object_Diagnosticable extends core.Object {};
  (Object_Diagnosticable$36.new = function() {
  }).prototype = Object_Diagnosticable$36.prototype;
  dart.applyMixin(Object_Diagnosticable$36, diagnostics.Diagnosticable);
  image_stream.ImageChunkEvent = class ImageChunkEvent extends Object_Diagnosticable$36 {
    get cumulativeBytesLoaded() {
      return this[cumulativeBytesLoaded$];
    }
    set cumulativeBytesLoaded(value) {
      super.cumulativeBytesLoaded = value;
    }
    get expectedTotalBytes() {
      return this[expectedTotalBytes$];
    }
    set expectedTotalBytes(value) {
      super.expectedTotalBytes = value;
    }
    debugFillProperties(properties) {
      super.debugFillProperties(properties);
      properties.add(new diagnostics.IntProperty.new("cumulativeBytesLoaded", this.cumulativeBytesLoaded));
      properties.add(new diagnostics.IntProperty.new("expectedTotalBytes", this.expectedTotalBytes));
    }
  };
  (image_stream.ImageChunkEvent.new = function(opts) {
    let cumulativeBytesLoaded = opts && 'cumulativeBytesLoaded' in opts ? opts.cumulativeBytesLoaded : null;
    let expectedTotalBytes = opts && 'expectedTotalBytes' in opts ? opts.expectedTotalBytes : null;
    this[cumulativeBytesLoaded$] = cumulativeBytesLoaded;
    this[expectedTotalBytes$] = expectedTotalBytes;
    if (!(cumulativeBytesLoaded >= 0)) dart.assertFailed(null, I[0], 264, 15, "cumulativeBytesLoaded >= 0");
    if (!(expectedTotalBytes == null || dart.notNull(expectedTotalBytes) >= 0)) dart.assertFailed(null, I[0], 265, 15, "expectedTotalBytes == null || expectedTotalBytes >= 0");
    ;
  }).prototype = image_stream.ImageChunkEvent.prototype;
  dart.addTypeTests(image_stream.ImageChunkEvent);
  dart.addTypeCaches(image_stream.ImageChunkEvent);
  dart.setLibraryUri(image_stream.ImageChunkEvent, I[1]);
  dart.setFieldSignature(image_stream.ImageChunkEvent, () => ({
    __proto__: dart.getFields(image_stream.ImageChunkEvent.__proto__),
    cumulativeBytesLoaded: dart.finalFieldType(core.int),
    expectedTotalBytes: dart.finalFieldType(dart.nullable(core.int))
  }));
  var _completer$ = dart.privateName(image_stream, "_completer");
  var _listeners = dart.privateName(image_stream, "_listeners");
  const Object_Diagnosticable$36$ = class Object_Diagnosticable extends core.Object {};
  (Object_Diagnosticable$36$.new = function() {
  }).prototype = Object_Diagnosticable$36$.prototype;
  dart.applyMixin(Object_Diagnosticable$36$, diagnostics.Diagnosticable);
  image_stream.ImageStream = class ImageStream extends Object_Diagnosticable$36$ {
    get completer() {
      return this[_completer$];
    }
    setCompleter(value) {
      if (!(this[_completer$] == null)) dart.assertFailed(null, I[0], 335, 12, "_completer == null");
      this[_completer$] = value;
      if (this[_listeners] != null) {
        let initialListeners = dart.nullCheck(this[_listeners]);
        this[_listeners] = null;
        initialListeners[$forEach](dart.bind(dart.nullCheck(this[_completer$]), 'addListener'));
      }
    }
    addListener(listener) {
      if (this[_completer$] != null) return dart.nullCheck(this[_completer$]).addListener(listener);
      this[_listeners] == null ? this[_listeners] = T.JSArrayOfImageStreamListener().of([]) : null;
      dart.nullCheck(this[_listeners])[$add](listener);
    }
    removeListener(listener) {
      if (this[_completer$] != null) return dart.nullCheck(this[_completer$]).removeListener(listener);
      if (!(this[_listeners] != null)) dart.assertFailed(null, I[0], 379, 12, "_listeners != null");
      for (let i = 0; i < dart.nullCheck(this[_listeners])[$length]; i = i + 1) {
        if (dart.nullCheck(this[_listeners])[$_get](i)._equals(listener)) {
          dart.nullCheck(this[_listeners])[$removeAt](i);
          break;
        }
      }
    }
    get key() {
      let t0;
      t0 = this[_completer$];
      return t0 == null ? this : t0;
    }
    debugFillProperties(properties) {
      let t0, t0$, t0$0, t0$1;
      super.debugFillProperties(properties);
      properties.add(new (T.ObjectFlagPropertyOfImageStreamCompleter()).new("completer", this[_completer$], {ifPresent: (t0 = this[_completer$], t0 == null ? null : t0.toStringShort()), ifNull: "unresolved"}));
      properties.add(new (T.ObjectFlagPropertyOfListOfImageStreamListener()).new("listeners", this[_listeners], {ifPresent: dart.str((t0$ = this[_listeners], t0$ == null ? null : t0$[$length])) + " listener" + ((t0$0 = this[_listeners], t0$0 == null ? null : t0$0[$length]) === 1 ? "" : "s"), ifNull: "no listeners", level: this[_completer$] != null ? diagnostics.DiagnosticLevel.hidden : diagnostics.DiagnosticLevel.info}));
      t0$1 = this[_completer$];
      t0$1 == null ? null : t0$1.debugFillProperties(properties);
    }
  };
  (image_stream.ImageStream.new = function() {
    this[_completer$] = null;
    this[_listeners] = null;
    ;
  }).prototype = image_stream.ImageStream.prototype;
  dart.addTypeTests(image_stream.ImageStream);
  dart.addTypeCaches(image_stream.ImageStream);
  dart.setMethodSignature(image_stream.ImageStream, () => ({
    __proto__: dart.getMethods(image_stream.ImageStream.__proto__),
    setCompleter: dart.fnType(dart.void, [image_stream.ImageStreamCompleter]),
    addListener: dart.fnType(dart.void, [image_stream.ImageStreamListener]),
    removeListener: dart.fnType(dart.void, [image_stream.ImageStreamListener])
  }));
  dart.setGetterSignature(image_stream.ImageStream, () => ({
    __proto__: dart.getGetters(image_stream.ImageStream.__proto__),
    completer: dart.nullable(image_stream.ImageStreamCompleter),
    key: core.Object
  }));
  dart.setLibraryUri(image_stream.ImageStream, I[1]);
  dart.setFieldSignature(image_stream.ImageStream, () => ({
    __proto__: dart.getFields(image_stream.ImageStream.__proto__),
    [_completer$]: dart.fieldType(dart.nullable(image_stream.ImageStreamCompleter)),
    [_listeners]: dart.fieldType(dart.nullable(core.List$(image_stream.ImageStreamListener)))
  }));
  var _keepAliveHandles = dart.privateName(image_stream, "_keepAliveHandles");
  var _disposed = dart.privateName(image_stream, "_disposed");
  var _maybeDispose = dart.privateName(image_stream, "_maybeDispose");
  image_stream.ImageStreamCompleterHandle = class ImageStreamCompleterHandle extends core.Object {
    dispose() {
      let t0;
      if (!(this[_completer$] != null)) dart.assertFailed(null, I[0], 442, 12, "_completer != null");
      if (!(dart.nullCheck(this[_completer$])[_keepAliveHandles] > 0)) dart.assertFailed(null, I[0], 443, 12, "_completer!._keepAliveHandles > 0");
      if (!!dart.nullCheck(this[_completer$])[_disposed]) dart.assertFailed(null, I[0], 444, 12, "!_completer!._disposed");
      t0 = dart.nullCheck(this[_completer$]);
      t0[_keepAliveHandles] = t0[_keepAliveHandles] - 1;
      dart.nullCheck(this[_completer$])[_maybeDispose]();
      this[_completer$] = null;
    }
  };
  (image_stream.ImageStreamCompleterHandle.__ = function(_completer) {
    let t0;
    this[_completer$] = _completer;
    t0 = dart.nullCheck(this[_completer$]);
    t0[_keepAliveHandles] = t0[_keepAliveHandles] + 1;
  }).prototype = image_stream.ImageStreamCompleterHandle.prototype;
  dart.addTypeTests(image_stream.ImageStreamCompleterHandle);
  dart.addTypeCaches(image_stream.ImageStreamCompleterHandle);
  dart.setMethodSignature(image_stream.ImageStreamCompleterHandle, () => ({
    __proto__: dart.getMethods(image_stream.ImageStreamCompleterHandle.__proto__),
    dispose: dart.fnType(dart.void, [])
  }));
  dart.setLibraryUri(image_stream.ImageStreamCompleterHandle, I[1]);
  dart.setFieldSignature(image_stream.ImageStreamCompleterHandle, () => ({
    __proto__: dart.getFields(image_stream.ImageStreamCompleterHandle.__proto__),
    [_completer$]: dart.fieldType(dart.nullable(image_stream.ImageStreamCompleter))
  }));
  var debugLabel = dart.privateName(image_stream, "ImageStreamCompleter.debugLabel");
  var _currentImage = dart.privateName(image_stream, "_currentImage");
  var _currentError = dart.privateName(image_stream, "_currentError");
  var _hadAtLeastOneListener = dart.privateName(image_stream, "_hadAtLeastOneListener");
  var _onLastListenerRemovedCallbacks = dart.privateName(image_stream, "_onLastListenerRemovedCallbacks");
  var _checkDisposed = dart.privateName(image_stream, "_checkDisposed");
  const Object_Diagnosticable$36$0 = class Object_Diagnosticable extends core.Object {};
  (Object_Diagnosticable$36$0.new = function() {
  }).prototype = Object_Diagnosticable$36$0.prototype;
  dart.applyMixin(Object_Diagnosticable$36$0, diagnostics.Diagnosticable);
  image_stream.ImageStreamCompleter = class ImageStreamCompleter extends Object_Diagnosticable$36$0 {
    get debugLabel() {
      return this[debugLabel];
    }
    set debugLabel(value) {
      this[debugLabel] = value;
    }
    get hasListeners() {
      return this[_listeners][$isNotEmpty];
    }
    addListener(listener) {
      let t2, t1, t0;
      this[_checkDisposed]();
      this[_hadAtLeastOneListener] = true;
      this[_listeners][$add](listener);
      if (this[_currentImage] != null) {
        try {
          t0 = listener;
          t1 = dart.nullCheck(this[_currentImage]).clone();
          t2 = true;
          t0.onImage(t1, t2);
>>>>>>> feature-b
        } catch (e) {
          let exception = dart.getThrown(e);
          let stack = dart.stackTrace(e);
          if (core.Object.is(exception)) {
<<<<<<< HEAD
            let collector = null;
            if (!dart.fn(() => {
              collector = dart.fn(() => new (T$.SyncIterableOfDiagnosticsNode()).new(function*() {
                yield new (T$.DiagnosticsPropertyOfListOfFrameTimingTovoid()).new("The TimingsCallback that gets executed was", callback, {style: diagnostics.DiagnosticsTreeStyle.errorProperty});
              }), T$.VoidToIterableOfDiagnosticsNode());
              return true;
            }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 293, 16, "() {\r\n          collector = () sync* {\r\n            yield DiagnosticsProperty<TimingsCallback>(\r\n              'The TimingsCallback that gets executed was',\r\n              callback,\r\n              style: DiagnosticsTreeStyle.errorProperty,\r\n            );\r\n          };\r\n          return true;\r\n        }()");
            assertions.FlutterError.reportError(new assertions.FlutterErrorDetails.new({exception: exception, stack: stack, context: new assertions.ErrorDescription.new("while executing callbacks for FrameTiming"), informationCollector: collector}));
=======
            this.reportError({context: new assertions.ErrorDescription.new("by a synchronously-called image listener"), exception: exception, stack: stack});
>>>>>>> feature-b
          } else
            throw e;
        }
      }
<<<<<<< HEAD
    }
    initServiceExtensions() {
      super.initServiceExtensions();
      if (!false) {
        this.registerNumericServiceExtension({name: "timeDilation", getter: dart.fn(() => async.async(core.double, function*() {
            return binding$.timeDilation;
          }), T$.VoidToFutureOfdouble()), setter: dart.fn(value => async.async(dart.void, function*() {
            binding$.timeDilation = value;
          }), T$.doubleToFutureOfvoid())});
      }
    }
    get lifecycleState() {
      return this[_lifecycleState];
    }
    handleAppLifecycleStateChanged(state) {
      if (!(state !== null)) dart.assertFailed(null, I[0], 352, 12, "state != null");
      this[_lifecycleState] = state;
      switch (state) {
        case C[8] || CT.C8:
        case C[9] || CT.C9:
        {
          this[_setFramesEnabledState](true);
          break;
        }
        case C[10] || CT.C10:
        case C[11] || CT.C11:
        {
          this[_setFramesEnabledState](false);
          break;
        }
      }
    }
    scheduleTask(T, task, priority, opts) {
      let debugLabel = opts && 'debugLabel' in opts ? opts.debugLabel : null;
      let flow = opts && 'flow' in opts ? opts.flow : null;
      let isFirstTask = this[_taskQueue].isEmpty;
      let entry = new (binding$._TaskEntry$(T)).new(task, priority.value, debugLabel, flow);
      this[_taskQueue].add(entry);
      if (isFirstTask && !this.locked) this[_ensureEventLoopCallback]();
      return entry.completer.future;
    }
    unlocked() {
      super.unlocked();
      if (this[_taskQueue].isNotEmpty) this[_ensureEventLoopCallback]();
    }
    [_ensureEventLoopCallback]() {
      if (!!this.locked) dart.assertFailed(null, I[0], 427, 12, "!locked");
      if (!this[_taskQueue].isNotEmpty) dart.assertFailed(null, I[0], 428, 12, "_taskQueue.isNotEmpty");
      if (this[_hasRequestedAnEventLoopCallback]) return;
      this[_hasRequestedAnEventLoopCallback] = true;
      async.Timer.run(dart.bind(this, _runTasks));
    }
    [_runTasks]() {
      this[_hasRequestedAnEventLoopCallback] = false;
      if (this.handleEventLoopCallback()) this[_ensureEventLoopCallback]();
    }
    handleEventLoopCallback() {
      let t2;
      if (this[_taskQueue].isEmpty || this.locked) return false;
      let entry = this[_taskQueue].first;
      if (t2 = entry.priority, this.schedulingStrategy({priority: t2, scheduler: this})) {
        try {
          this[_taskQueue].removeFirst();
          entry.run();
        } catch (e) {
          let exception = dart.getThrown(e);
          let exceptionStack = dart.stackTrace(e);
          if (core.Object.is(exception)) {
            let callbackStack = null;
            if (!dart.fn(() => {
              callbackStack = entry.debugStack;
              return true;
            }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 463, 16, "() {\r\n          callbackStack = entry.debugStack;\r\n          return true;\r\n        }()");
            assertions.FlutterError.reportError(new assertions.FlutterErrorDetails.new({exception: exception, stack: exceptionStack, library: "scheduler library", context: new assertions.ErrorDescription.new("during a task callback"), informationCollector: callbackStack == null ? null : dart.fn(() => new (T$.SyncIterableOfDiagnosticsNode()).new(function*() {
                yield new assertions.DiagnosticsStackTrace.new("\nThis exception was thrown in the context of a scheduler callback. " + "When the scheduler callback was _registered_ (as opposed to when the " + "exception was thrown), this was the stack", callbackStack);
              }), T$.VoidToIterableOfDiagnosticsNode())}));
          } else
            throw e;
        }
        return this[_taskQueue].isNotEmpty;
      }
      return false;
    }
    get transientCallbackCount() {
      return this[_transientCallbacks][$length];
    }
    scheduleFrameCallback(callback, opts) {
      let rescheduling = opts && 'rescheduling' in opts ? opts.rescheduling : false;
      this.scheduleFrame();
      this[_nextFrameCallbackId] = this[_nextFrameCallbackId] + 1;
      this[_transientCallbacks][$_set](this[_nextFrameCallbackId], new binding$._FrameCallbackEntry.new(callback, {rescheduling: rescheduling}));
      return this[_nextFrameCallbackId];
    }
    cancelFrameCallbackWithId(id) {
      if (!(id > 0)) dart.assertFailed(null, I[0], 535, 12, "id > 0");
      this[_transientCallbacks][$remove](id);
      this[_removedIds].add(id);
    }
    debugAssertNoTransientCallbacks(reason) {
      if (!dart.fn(() => {
        if (this.transientCallbackCount > 0) {
          let count = this.transientCallbackCount;
          let callbacks = T$.LinkedHashMapOfint$_FrameCallbackEntry().from(this[_transientCallbacks]);
          assertions.FlutterError.reportError(new assertions.FlutterErrorDetails.new({exception: reason, library: "scheduler library", informationCollector: dart.fn(() => new (T$.SyncIterableOfDiagnosticsNode()).new(function*() {
              if (count === 1) {
                yield new assertions.ErrorDescription.new("There was one transient callback left. " + "The stack trace for when it was registered is as follows:");
              } else {
                yield new assertions.ErrorDescription.new("There were " + dart.str(count) + " transient callbacks left. " + "The stack traces for when they were registered are as follows:");
              }
              for (let id of callbacks[$keys]) {
                let entry = dart.nullCheck(callbacks[$_get](id));
                yield new assertions.DiagnosticsStackTrace.new("── callback " + dart.str(id) + " ──", entry.debugStack, {showSeparator: false});
              }
            }), T$.VoidToIterableOfDiagnosticsNode())}));
        }
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 561, 12, "() {\r\n      if (transientCallbackCount > 0) {\r\n        // We cache the values so that we can produce them later\r\n        // even if the information collector is called after\r\n        // the problem has been resolved.\r\n        final int count = transientCallbackCount;\r\n        final Map<int, _FrameCallbackEntry> callbacks = Map<int, _FrameCallbackEntry>.from(_transientCallbacks);\r\n        FlutterError.reportError(FlutterErrorDetails(\r\n          exception: reason,\r\n          library: 'scheduler library',\r\n          informationCollector: () sync* {\r\n            if (count == 1) {\r\n              // TODO(jacobr): I have added an extra line break in this case.\r\n              yield ErrorDescription(\r\n                'There was one transient callback left. '\r\n                'The stack trace for when it was registered is as follows:',\r\n              );\r\n            } else {\r\n              yield ErrorDescription(\r\n                'There were $count transient callbacks left. '\r\n                'The stack traces for when they were registered are as follows:',\r\n              );\r\n            }\r\n            for (final int id in callbacks.keys) {\r\n              final _FrameCallbackEntry entry = callbacks[id]!;\r\n              yield DiagnosticsStackTrace('── callback $id ──', entry.debugStack, showSeparator: false);\r\n            }\r\n          },\r\n        ));\r\n      }\r\n      return true;\r\n    }()");
      return true;
    }
    addPersistentFrameCallback(callback) {
      this[_persistentCallbacks][$add](callback);
    }
    addPostFrameCallback(callback) {
      this[_postFrameCallbacks][$add](callback);
    }
    get endOfFrame() {
      if (this[_nextFrameCompleter] == null) {
        if (this.schedulerPhase === binding$.SchedulerPhase.idle) this.scheduleFrame();
        this[_nextFrameCompleter] = T$.CompleterOfvoid().new();
        this.addPostFrameCallback(dart.fn(timeStamp => {
          dart.nullCheck(this[_nextFrameCompleter]).complete();
          this[_nextFrameCompleter] = null;
        }, T$.DurationTovoid()));
      }
      return dart.nullCheck(this[_nextFrameCompleter]).future;
    }
    get hasScheduledFrame() {
      return this[_hasScheduledFrame];
    }
    get schedulerPhase() {
      return this[_schedulerPhase];
    }
    get framesEnabled() {
      return this[_framesEnabled];
    }
    [_setFramesEnabledState](enabled) {
      if (this[_framesEnabled] === enabled) return;
      this[_framesEnabled] = enabled;
      if (enabled) this.scheduleFrame();
    }
    ensureFrameCallbacksRegistered() {
      let t3, t3$;
      t3 = this.window;
      t3.onBeginFrame == null ? t3.onBeginFrame = dart.bind(this, _handleBeginFrame) : null;
      t3$ = this.window;
      t3$.onDrawFrame == null ? t3$.onDrawFrame = dart.bind(this, _handleDrawFrame) : null;
    }
    ensureVisualUpdate() {
      switch (this.schedulerPhase) {
        case C[0] || CT.C0:
        case C[4] || CT.C4:
        {
          this.scheduleFrame();
          return;
        }
        case C[1] || CT.C1:
        case C[2] || CT.C2:
        case C[3] || CT.C3:
        {
          return;
        }
      }
    }
    scheduleFrame() {
      if (this[_hasScheduledFrame] || !this.framesEnabled) return;
      if (!dart.fn(() => {
        if (debug$.debugPrintScheduleFrameStacks) assertions.debugPrintStack({label: "scheduleFrame() called. Current phase is " + dart.str(this.schedulerPhase) + "."});
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 787, 12, "() {\r\n      if (debugPrintScheduleFrameStacks)\r\n        debugPrintStack(label: 'scheduleFrame() called. Current phase is $schedulerPhase.');\r\n      return true;\r\n    }()");
      this.ensureFrameCallbacksRegistered();
      this.window.scheduleFrame();
      this[_hasScheduledFrame] = true;
    }
    scheduleForcedFrame() {
      if (!this.framesEnabled) return;
      if (this[_hasScheduledFrame]) return;
      if (!dart.fn(() => {
        if (debug$.debugPrintScheduleFrameStacks) assertions.debugPrintStack({label: "scheduleForcedFrame() called. Current phase is " + dart.str(this.schedulerPhase) + "."});
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 825, 12, "() {\r\n      if (debugPrintScheduleFrameStacks)\r\n        debugPrintStack(label: 'scheduleForcedFrame() called. Current phase is $schedulerPhase.');\r\n      return true;\r\n    }()");
      this.window.scheduleFrame();
      this[_hasScheduledFrame] = true;
    }
    scheduleWarmUpFrame() {
      if (this[_warmUpFrame] || this.schedulerPhase !== binding$.SchedulerPhase.idle) return;
      this[_warmUpFrame] = true;
      developer.Timeline.startSync("Warm-up frame");
      let hadScheduledFrame = this[_hasScheduledFrame];
      async.Timer.run(dart.fn(() => {
        if (!this[_warmUpFrame]) dart.assertFailed(null, I[0], 860, 14, "_warmUpFrame");
        this.handleBeginFrame(null);
      }, T$.VoidTovoid()));
      async.Timer.run(dart.fn(() => {
        if (!this[_warmUpFrame]) dart.assertFailed(null, I[0], 864, 14, "_warmUpFrame");
        this.handleDrawFrame();
        this.resetEpoch();
        this[_warmUpFrame] = false;
        if (hadScheduledFrame) this.scheduleFrame();
      }, T$.VoidTovoid()));
      this.lockEvents(dart.fn(() => async.async(dart.void, (function*() {
        yield this.endOfFrame;
        developer.Timeline.finishSync();
      }).bind(this)), T$.VoidToFutureOfvoid()));
    }
    resetEpoch() {
      this[_epochStart] = this[_adjustForEpoch](this[_lastRawTimeStamp]);
      this[_firstRawTimeStampInEpoch] = null;
    }
    [_adjustForEpoch](rawTimeStamp) {
      let rawDurationSinceEpoch = this[_firstRawTimeStampInEpoch] == null ? core.Duration.zero : rawTimeStamp['-'](dart.nullCheck(this[_firstRawTimeStampInEpoch]));
      return new core.Duration.new({microseconds: (rawDurationSinceEpoch.inMicroseconds / binding$.timeDilation)[$round]() + this[_epochStart].inMicroseconds});
    }
    get currentFrameTimeStamp() {
      if (!(this[_currentFrameTimeStamp] != null)) dart.assertFailed(null, I[0], 933, 12, "_currentFrameTimeStamp != null");
      return dart.nullCheck(this[_currentFrameTimeStamp]);
    }
    get currentSystemFrameTimeStamp() {
      if (!(this[_lastRawTimeStamp] !== null)) dart.assertFailed(null, I[0], 951, 12, "_lastRawTimeStamp != null");
      return this[_lastRawTimeStamp];
    }
    [_handleBeginFrame](rawTimeStamp) {
      if (this[_warmUpFrame]) {
        if (!!this[_rescheduleAfterWarmUpFrame]) dart.assertFailed(null, I[0], 973, 14, "!_rescheduleAfterWarmUpFrame");
        this[_rescheduleAfterWarmUpFrame] = true;
        return;
      }
      this.handleBeginFrame(rawTimeStamp);
    }
    [_handleDrawFrame]() {
      if (this[_rescheduleAfterWarmUpFrame]) {
        this[_rescheduleAfterWarmUpFrame] = false;
        this.addPostFrameCallback(dart.fn(timeStamp => {
          this[_hasScheduledFrame] = false;
          this.scheduleFrame();
        }, T$.DurationTovoid()));
        return;
      }
      this.handleDrawFrame();
    }
    handleBeginFrame(rawTimeStamp) {
      let t3;
      developer.Timeline.startSync("Frame", {arguments: debug.timelineArgumentsIndicatingLandmarkEvent});
      this[_firstRawTimeStampInEpoch] == null ? this[_firstRawTimeStampInEpoch] = rawTimeStamp : null;
      this[_currentFrameTimeStamp] = this[_adjustForEpoch]((t3 = rawTimeStamp, t3 == null ? this[_lastRawTimeStamp] : t3));
      if (rawTimeStamp != null) this[_lastRawTimeStamp] = rawTimeStamp;
      if (!dart.fn(() => {
        this[_debugFrameNumber] = this[_debugFrameNumber] + 1;
        if (debug$.debugPrintBeginFrameBanner || debug$.debugPrintEndFrameBanner) {
          let frameTimeStampDescription = new core.StringBuffer.new();
          if (rawTimeStamp != null) {
            binding$.SchedulerBinding._debugDescribeTimeStamp(dart.nullCheck(this[_currentFrameTimeStamp]), frameTimeStampDescription);
          } else {
            frameTimeStampDescription.write("(warm-up frame)");
          }
          this[_debugBanner] = "▄▄▄▄▄▄▄▄ Frame " + this[_debugFrameNumber][$toString]()[$padRight](7) + "   " + frameTimeStampDescription.toString()[$padLeft](18) + " ▄▄▄▄▄▄▄▄";
          if (debug$.debugPrintBeginFrameBanner) print.debugPrint(this[_debugBanner]);
        }
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 1031, 12, "() {\r\n      _debugFrameNumber += 1;\r\n\r\n      if (debugPrintBeginFrameBanner || debugPrintEndFrameBanner) {\r\n        final StringBuffer frameTimeStampDescription = StringBuffer();\r\n        if (rawTimeStamp != null) {\r\n          _debugDescribeTimeStamp(_currentFrameTimeStamp!, frameTimeStampDescription);\r\n        } else {\r\n          frameTimeStampDescription.write('(warm-up frame)');\r\n        }\r\n        _debugBanner = '▄▄▄▄▄▄▄▄ Frame ${_debugFrameNumber.toString().padRight(7)}   ${frameTimeStampDescription.toString().padLeft(18)} ▄▄▄▄▄▄▄▄';\r\n        if (debugPrintBeginFrameBanner)\r\n          debugPrint(_debugBanner);\r\n      }\r\n      return true;\r\n    }()");
      if (!(this.schedulerPhase === binding$.SchedulerPhase.idle)) dart.assertFailed(null, I[0], 1048, 12, "schedulerPhase == SchedulerPhase.idle");
      this[_hasScheduledFrame] = false;
      try {
        developer.Timeline.startSync("Animate", {arguments: debug.timelineArgumentsIndicatingLandmarkEvent});
        this[_schedulerPhase] = binding$.SchedulerPhase.transientCallbacks;
        let callbacks = this[_transientCallbacks];
        this[_transientCallbacks] = new (T$.IdentityMapOfint$_FrameCallbackEntry()).new();
        callbacks[$forEach](dart.fn((id, callbackEntry) => {
          if (!this[_removedIds].contains(id)) this[_invokeFrameCallback](callbackEntry.callback, dart.nullCheck(this[_currentFrameTimeStamp]), callbackEntry.debugStack);
        }, T$.intAnd_FrameCallbackEntryTovoid()));
        this[_removedIds].clear();
      } finally {
        this[_schedulerPhase] = binding$.SchedulerPhase.midFrameMicrotasks;
      }
    }
    handleDrawFrame() {
      if (!(this[_schedulerPhase] === binding$.SchedulerPhase.midFrameMicrotasks)) dart.assertFailed(null, I[0], 1076, 12, "_schedulerPhase == SchedulerPhase.midFrameMicrotasks");
      developer.Timeline.finishSync();
      try {
        this[_schedulerPhase] = binding$.SchedulerPhase.persistentCallbacks;
        for (let callback of this[_persistentCallbacks])
          this[_invokeFrameCallback](callback, dart.nullCheck(this[_currentFrameTimeStamp]));
        this[_schedulerPhase] = binding$.SchedulerPhase.postFrameCallbacks;
        let localPostFrameCallbacks = T$.ListOfDurationTovoid().from(this[_postFrameCallbacks]);
        this[_postFrameCallbacks][$clear]();
        for (let callback of localPostFrameCallbacks)
          this[_invokeFrameCallback](callback, dart.nullCheck(this[_currentFrameTimeStamp]));
      } finally {
        this[_schedulerPhase] = binding$.SchedulerPhase.idle;
        developer.Timeline.finishSync();
        if (!dart.fn(() => {
          if (debug$.debugPrintEndFrameBanner) print.debugPrint("▀"[$times](dart.nullCheck(this[_debugBanner]).length));
          this[_debugBanner] = null;
          return true;
        }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 1094, 14, "() {\r\n        if (debugPrintEndFrameBanner)\r\n          debugPrint('▀' * _debugBanner!.length);\r\n        _debugBanner = null;\r\n        return true;\r\n      }()");
        this[_currentFrameTimeStamp] = null;
      }
    }
    [_profileFramePostEvent](frameNumber, frameTiming) {
      this.postEvent("Flutter.Frame", new (T$.IdentityMapOfString$dynamic()).from(["number", frameNumber, "startTime", frameTiming.timestampInMicroseconds(ui.FramePhase.buildStart), "elapsed", frameTiming.totalSpan.inMicroseconds, "build", frameTiming.buildDuration.inMicroseconds, "raster", frameTiming.rasterDuration.inMicroseconds, "vsyncOverhead", frameTiming.vsyncOverhead.inMicroseconds]));
    }
    [_invokeFrameCallback](callback, timeStamp, callbackStack = null) {
      if (!(callback !== null)) dart.assertFailed(null, I[0], 1137, 12, "callback != null");
      if (!(binding$._FrameCallbackEntry.debugCurrentCallbackStack == null)) dart.assertFailed(null, I[0], 1138, 12, "_FrameCallbackEntry.debugCurrentCallbackStack == null");
      if (!dart.fn(() => {
        binding$._FrameCallbackEntry.debugCurrentCallbackStack = callbackStack;
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 1139, 12, "() {\r\n      _FrameCallbackEntry.debugCurrentCallbackStack = callbackStack;\r\n      return true;\r\n    }()");
      try {
        callback(timeStamp);
      } catch (e) {
        let exception = dart.getThrown(e);
        let exceptionStack = dart.stackTrace(e);
        if (core.Object.is(exception)) {
          assertions.FlutterError.reportError(new assertions.FlutterErrorDetails.new({exception: exception, stack: exceptionStack, library: "scheduler library", context: new assertions.ErrorDescription.new("during a scheduler callback"), informationCollector: callbackStack == null ? null : dart.fn(() => new (T$.SyncIterableOfDiagnosticsNode()).new(function*() {
              yield new assertions.DiagnosticsStackTrace.new("\nThis exception was thrown in the context of a scheduler callback. " + "When the scheduler callback was _registered_ (as opposed to when the " + "exception was thrown), this was the stack", callbackStack);
            }), T$.VoidToIterableOfDiagnosticsNode())}));
        } else
          throw e;
      }
      if (!dart.fn(() => {
        binding$._FrameCallbackEntry.debugCurrentCallbackStack = null;
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 1161, 12, "() {\r\n      _FrameCallbackEntry.debugCurrentCallbackStack = null;\r\n      return true;\r\n    }()");
    }
  };
  (binding$.SchedulerBinding[dart.mixinNew] = function() {
    this[_timingsCallbacks] = T$.JSArrayOfListOfFrameTimingTovoid().of([]);
    this[_lifecycleState] = null;
    this[schedulingStrategy] = C[6] || CT.C6;
    this[_taskQueue] = new (T$.HeapPriorityQueueOf_TaskEntry()).new(C[7] || CT.C7);
    this[_hasRequestedAnEventLoopCallback] = false;
    this[_nextFrameCallbackId] = 0;
    this[_transientCallbacks] = new (T$.IdentityMapOfint$_FrameCallbackEntry()).new();
    this[_removedIds] = new (T$._IdentityHashSetOfint()).new();
    this[_persistentCallbacks] = T$.JSArrayOfDurationTovoid().of([]);
    this[_postFrameCallbacks] = T$.JSArrayOfDurationTovoid().of([]);
    this[_nextFrameCompleter] = null;
    this[_hasScheduledFrame] = false;
    this[_schedulerPhase] = binding$.SchedulerPhase.idle;
    this[_framesEnabled] = true;
    this[_warmUpFrame] = false;
    this[_firstRawTimeStampInEpoch] = null;
    this[_epochStart] = core.Duration.zero;
    this[_lastRawTimeStamp] = core.Duration.zero;
    this[_currentFrameTimeStamp] = null;
    this[_debugFrameNumber] = 0;
    this[_debugBanner] = null;
    this[_rescheduleAfterWarmUpFrame] = false;
  }).prototype = binding$.SchedulerBinding.prototype;
  dart.addTypeTests(binding$.SchedulerBinding);
  dart.addTypeCaches(binding$.SchedulerBinding);
  binding$.SchedulerBinding[dart.implements] = () => [binding.BindingBase];
  dart.setMethodSignature(binding$.SchedulerBinding, () => ({
    __proto__: dart.getMethods(binding$.SchedulerBinding.__proto__),
    addTimingsCallback: dart.fnType(dart.void, [dart.fnType(dart.void, [core.List$(ui.FrameTiming)])]),
    removeTimingsCallback: dart.fnType(dart.void, [dart.fnType(dart.void, [core.List$(ui.FrameTiming)])]),
    [_executeTimingsCallbacks]: dart.fnType(dart.void, [core.List$(ui.FrameTiming)]),
    handleAppLifecycleStateChanged: dart.fnType(dart.void, [ui.AppLifecycleState]),
    scheduleTask: dart.gFnType(T => [async.Future$(T), [dart.fnType(T, []), priority$.Priority], {debugLabel: dart.nullable(core.String), flow: dart.nullable(developer.Flow)}, {}], T => [dart.nullable(core.Object)]),
    [_ensureEventLoopCallback]: dart.fnType(dart.void, []),
    [_runTasks]: dart.fnType(dart.void, []),
    handleEventLoopCallback: dart.fnType(core.bool, []),
    scheduleFrameCallback: dart.fnType(core.int, [dart.fnType(dart.void, [core.Duration])], {rescheduling: core.bool}, {}),
    cancelFrameCallbackWithId: dart.fnType(dart.void, [core.int]),
    debugAssertNoTransientCallbacks: dart.fnType(core.bool, [core.String]),
    addPersistentFrameCallback: dart.fnType(dart.void, [dart.fnType(dart.void, [core.Duration])]),
    addPostFrameCallback: dart.fnType(dart.void, [dart.fnType(dart.void, [core.Duration])]),
    [_setFramesEnabledState]: dart.fnType(dart.void, [core.bool]),
    ensureFrameCallbacksRegistered: dart.fnType(dart.void, []),
    ensureVisualUpdate: dart.fnType(dart.void, []),
    scheduleFrame: dart.fnType(dart.void, []),
    scheduleForcedFrame: dart.fnType(dart.void, []),
    scheduleWarmUpFrame: dart.fnType(dart.void, []),
    resetEpoch: dart.fnType(dart.void, []),
    [_adjustForEpoch]: dart.fnType(core.Duration, [core.Duration]),
    [_handleBeginFrame]: dart.fnType(dart.void, [core.Duration]),
    [_handleDrawFrame]: dart.fnType(dart.void, []),
    handleBeginFrame: dart.fnType(dart.void, [dart.nullable(core.Duration)]),
    handleDrawFrame: dart.fnType(dart.void, []),
    [_profileFramePostEvent]: dart.fnType(dart.void, [core.int, ui.FrameTiming]),
    [_invokeFrameCallback]: dart.fnType(dart.void, [dart.fnType(dart.void, [core.Duration]), core.Duration], [dart.nullable(core.StackTrace)])
  }));
  dart.setGetterSignature(binding$.SchedulerBinding, () => ({
    __proto__: dart.getGetters(binding$.SchedulerBinding.__proto__),
    lifecycleState: dart.nullable(ui.AppLifecycleState),
    transientCallbackCount: core.int,
    endOfFrame: async.Future$(dart.void),
    hasScheduledFrame: core.bool,
    schedulerPhase: binding$.SchedulerPhase,
    framesEnabled: core.bool,
    currentFrameTimeStamp: core.Duration,
    currentSystemFrameTimeStamp: core.Duration
  }));
  dart.setLibraryUri(binding$.SchedulerBinding, I[1]);
  dart.setFieldSignature(binding$.SchedulerBinding, () => ({
    __proto__: dart.getFields(binding$.SchedulerBinding.__proto__),
    [_timingsCallbacks]: dart.finalFieldType(core.List$(dart.fnType(dart.void, [core.List$(ui.FrameTiming)]))),
    [_lifecycleState]: dart.fieldType(dart.nullable(ui.AppLifecycleState)),
    schedulingStrategy: dart.fieldType(dart.fnType(core.bool, [], {}, {priority: core.int, scheduler: binding$.SchedulerBinding})),
    [_taskQueue]: dart.finalFieldType(priority_queue.PriorityQueue$(binding$._TaskEntry)),
    [_hasRequestedAnEventLoopCallback]: dart.fieldType(core.bool),
    [_nextFrameCallbackId]: dart.fieldType(core.int),
    [_transientCallbacks]: dart.fieldType(core.Map$(core.int, binding$._FrameCallbackEntry)),
    [_removedIds]: dart.finalFieldType(core.Set$(core.int)),
    [_persistentCallbacks]: dart.finalFieldType(core.List$(dart.fnType(dart.void, [core.Duration]))),
    [_postFrameCallbacks]: dart.finalFieldType(core.List$(dart.fnType(dart.void, [core.Duration]))),
    [_nextFrameCompleter]: dart.fieldType(dart.nullable(async.Completer$(dart.void))),
    [_hasScheduledFrame]: dart.fieldType(core.bool),
    [_schedulerPhase]: dart.fieldType(binding$.SchedulerPhase),
    [_framesEnabled]: dart.fieldType(core.bool),
    [_warmUpFrame]: dart.fieldType(core.bool),
    [_firstRawTimeStampInEpoch]: dart.fieldType(dart.nullable(core.Duration)),
    [_epochStart]: dart.fieldType(core.Duration),
    [_lastRawTimeStamp]: dart.fieldType(core.Duration),
    [_currentFrameTimeStamp]: dart.fieldType(dart.nullable(core.Duration)),
    [_debugFrameNumber]: dart.fieldType(core.int),
    [_debugBanner]: dart.fieldType(dart.nullable(core.String)),
    [_rescheduleAfterWarmUpFrame]: dart.fieldType(core.bool)
  }));
  dart.defineLazy(binding$.SchedulerBinding, {
    /*binding$.SchedulerBinding._instance*/get _instance() {
      return null;
    },
    set _instance(_) {}
  }, false);
  binding$.defaultSchedulingStrategy = function defaultSchedulingStrategy(opts) {
    let priority = opts && 'priority' in opts ? opts.priority : null;
    let scheduler = opts && 'scheduler' in opts ? opts.scheduler : null;
    if (scheduler.transientCallbackCount > 0) return priority >= priority$.Priority.animation.value;
    return true;
  };
  dart.copyProperties(binding$, {
    get timeDilation() {
      return binding$._timeDilation;
    },
    set timeDilation(value) {
      let t4;
      if (!(value > 0.0)) dart.assertFailed(null, I[0], 25, 10, "value > 0.0");
      if (binding$._timeDilation === value) return;
      t4 = binding$.SchedulerBinding.instance;
      t4 == null ? null : t4.resetEpoch();
      binding$._timeDilation = value;
    }
  });
  dart.defineLazy(binding$, {
    /*binding$._timeDilation*/get _timeDilation() {
      return 1.0;
    },
    set _timeDilation(_) {}
  }, false);
  dart.trackLibraries("packages/flutter/src/scheduler/binding.dart", {
    "package:flutter/src/scheduler/binding.dart": binding$
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["binding.dart"],"names":[],"mappings":"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","file":"../../../../../../../E:/packages/flutter/src/scheduler/binding.dart.lib.js"}');
  // Exports:
  return {
    src__scheduler__binding: binding$
  };
}));

//# sourceMappingURL=binding.dart.lib.js.map
=======
      if (this[_currentError] != null && listener.onError != null) {
        try {
          dart.nullCheck(listener.onError)(dart.nullCheck(this[_currentError]).exception, dart.nullCheck(this[_currentError]).stack);
        } catch (e$) {
          let newException = dart.getThrown(e$);
          let newStack = dart.stackTrace(e$);
          if (core.Object.is(newException)) {
            if (!newException[$_equals](dart.nullCheck(this[_currentError]).exception)) {
              assertions.FlutterError.reportError(new assertions.FlutterErrorDetails.new({exception: newException, library: "image resource service", context: new assertions.ErrorDescription.new("by a synchronously-called image error listener"), stack: newStack}));
            }
          } else
            throw e$;
        }
      }
    }
    keepAlive() {
      this[_checkDisposed]();
      return new image_stream.ImageStreamCompleterHandle.__(this);
    }
    removeListener(listener) {
      this[_checkDisposed]();
      for (let i = 0; i < this[_listeners][$length]; i = i + 1) {
        if (this[_listeners][$_get](i)._equals(listener)) {
          this[_listeners][$removeAt](i);
          break;
        }
      }
      if (this[_listeners][$isEmpty]) {
        let callbacks = this[_onLastListenerRemovedCallbacks][$toList]();
        for (let callback of callbacks) {
          callback();
        }
        this[_onLastListenerRemovedCallbacks][$clear]();
        this[_maybeDispose]();
      }
    }
    [_maybeDispose]() {
      let t2;
      if (!this[_hadAtLeastOneListener] || this[_disposed] || this[_listeners][$isNotEmpty] || this[_keepAliveHandles] !== 0) {
        return;
      }
      t2 = this[_currentImage];
      t2 == null ? null : t2.dispose();
      this[_currentImage] = null;
      this[_disposed] = true;
    }
    [_checkDisposed]() {
      if (this[_disposed]) {
        dart.throw(new core.StateError.new("Stream has been disposed.\n" + "An ImageStream is considered disposed once at least one listener has " + "been added and subsequently all listeners have been removed and no " + "handles are outstanding from the keepAlive method.\n" + "To resolve this error, maintain at least one listener on the stream, " + "or create an ImageStreamCompleterHandle from the keepAlive " + "method, or create a new stream for the image."));
      }
    }
    addOnLastListenerRemovedCallback(callback) {
      if (!(callback !== null)) dart.assertFailed(null, I[0], 602, 12, "callback != null");
      this[_checkDisposed]();
      this[_onLastListenerRemovedCallbacks][$add](callback);
    }
    removeOnLastListenerRemovedCallback(callback) {
      if (!(callback !== null)) dart.assertFailed(null, I[0], 610, 12, "callback != null");
      this[_checkDisposed]();
      this[_onLastListenerRemovedCallbacks][$remove](callback);
    }
    setImage(image) {
      let t2, t4, t3, t2$;
      this[_checkDisposed]();
      t2 = this[_currentImage];
      t2 == null ? null : t2.dispose();
      this[_currentImage] = image;
      if (this[_listeners][$isEmpty]) return;
      let localListeners = T.ListOfImageStreamListener().from(this[_listeners]);
      for (let listener of localListeners) {
        try {
          t2$ = listener;
          t3 = image.clone();
          t4 = false;
          t2$.onImage(t3, t4);
        } catch (e) {
          let exception = dart.getThrown(e);
          let stack = dart.stackTrace(e);
          if (core.Object.is(exception)) {
            this.reportError({context: new assertions.ErrorDescription.new("by an image listener"), exception: exception, stack: stack});
          } else
            throw e;
        }
      }
    }
    reportError(opts) {
      let context = opts && 'context' in opts ? opts.context : null;
      let exception = opts && 'exception' in opts ? opts.exception : null;
      let stack = opts && 'stack' in opts ? opts.stack : null;
      let informationCollector = opts && 'informationCollector' in opts ? opts.informationCollector : null;
      let silent = opts && 'silent' in opts ? opts.silent : false;
      this[_currentError] = new assertions.FlutterErrorDetails.new({exception: exception, stack: stack, library: "image resource service", context: context, informationCollector: informationCollector, silent: silent});
      let localErrorListeners = this[_listeners][$map](T.ObjectAndStackTraceNToNvoid(), dart.fn(listener => listener.onError, T.ImageStreamListenerToFn()))[$whereType](T.ObjectAndStackTraceNTovoid())[$toList]();
      let handled = false;
      for (let errorListener of localErrorListeners) {
        try {
          errorListener(exception, stack);
          handled = true;
        } catch (e) {
          let newException = dart.getThrown(e);
          let newStack = dart.stackTrace(e);
          if (core.Object.is(newException)) {
            if (!newException[$_equals](exception)) {
              assertions.FlutterError.reportError(new assertions.FlutterErrorDetails.new({context: new assertions.ErrorDescription.new("when reporting an error to an image listener"), library: "image resource service", exception: newException, stack: newStack}));
            }
          } else
            throw e;
        }
      }
      if (!handled) {
        assertions.FlutterError.reportError(dart.nullCheck(this[_currentError]));
      }
    }
    reportImageChunkEvent(event) {
      this[_checkDisposed]();
      if (this.hasListeners) {
        let localListeners = this[_listeners][$map](T.ImageChunkEventToNvoid(), dart.fn(listener => listener.onChunk, T.ImageStreamListenerToFn$1()))[$whereType](T.ImageChunkEventTovoid())[$toList]();
        for (let listener of localListeners) {
          listener(event);
        }
      }
    }
    debugFillProperties(description) {
      super.debugFillProperties(description);
      description.add(new (T.DiagnosticsPropertyOfImageInfo()).new("current", this[_currentImage], {ifNull: "unresolved", showName: false}));
      description.add(new (T.ObjectFlagPropertyOfListOfImageStreamListener()).new("listeners", this[_listeners], {ifPresent: dart.str(this[_listeners][$length]) + " listener" + (this[_listeners][$length] === 1 ? "" : "s")}));
      description.add(new diagnostics.FlagProperty.new("disposed", {value: this[_disposed], ifTrue: "<disposed>"}));
    }
  };
  (image_stream.ImageStreamCompleter.new = function() {
    this[_listeners] = T.JSArrayOfImageStreamListener().of([]);
    this[_currentImage] = null;
    this[_currentError] = null;
    this[debugLabel] = null;
    this[_hadAtLeastOneListener] = false;
    this[_keepAliveHandles] = 0;
    this[_disposed] = false;
    this[_onLastListenerRemovedCallbacks] = T.JSArrayOfVoidTovoid().of([]);
    ;
  }).prototype = image_stream.ImageStreamCompleter.prototype;
  dart.addTypeTests(image_stream.ImageStreamCompleter);
  dart.addTypeCaches(image_stream.ImageStreamCompleter);
  dart.setMethodSignature(image_stream.ImageStreamCompleter, () => ({
    __proto__: dart.getMethods(image_stream.ImageStreamCompleter.__proto__),
    addListener: dart.fnType(dart.void, [image_stream.ImageStreamListener]),
    keepAlive: dart.fnType(image_stream.ImageStreamCompleterHandle, []),
    removeListener: dart.fnType(dart.void, [image_stream.ImageStreamListener]),
    [_maybeDispose]: dart.fnType(dart.void, []),
    [_checkDisposed]: dart.fnType(dart.void, []),
    addOnLastListenerRemovedCallback: dart.fnType(dart.void, [dart.fnType(dart.void, [])]),
    removeOnLastListenerRemovedCallback: dart.fnType(dart.void, [dart.fnType(dart.void, [])]),
    setImage: dart.fnType(dart.void, [image_stream.ImageInfo]),
    reportError: dart.fnType(dart.void, [], {context: dart.nullable(diagnostics.DiagnosticsNode), informationCollector: dart.nullable(dart.fnType(core.Iterable$(diagnostics.DiagnosticsNode), [])), silent: core.bool, stack: dart.nullable(core.StackTrace)}, {exception: core.Object}),
    reportImageChunkEvent: dart.fnType(dart.void, [image_stream.ImageChunkEvent])
  }));
  dart.setGetterSignature(image_stream.ImageStreamCompleter, () => ({
    __proto__: dart.getGetters(image_stream.ImageStreamCompleter.__proto__),
    hasListeners: core.bool
  }));
  dart.setLibraryUri(image_stream.ImageStreamCompleter, I[1]);
  dart.setFieldSignature(image_stream.ImageStreamCompleter, () => ({
    __proto__: dart.getFields(image_stream.ImageStreamCompleter.__proto__),
    [_listeners]: dart.finalFieldType(core.List$(image_stream.ImageStreamListener)),
    [_currentImage]: dart.fieldType(dart.nullable(image_stream.ImageInfo)),
    [_currentError]: dart.fieldType(dart.nullable(assertions.FlutterErrorDetails)),
    debugLabel: dart.fieldType(dart.nullable(core.String)),
    [_hadAtLeastOneListener]: dart.fieldType(core.bool),
    [_keepAliveHandles]: dart.fieldType(core.int),
    [_disposed]: dart.fieldType(core.bool),
    [_onLastListenerRemovedCallbacks]: dart.finalFieldType(core.List$(dart.fnType(dart.void, [])))
  }));
  image_stream.OneFrameImageStreamCompleter = class OneFrameImageStreamCompleter extends image_stream.ImageStreamCompleter {};
  (image_stream.OneFrameImageStreamCompleter.new = function(image, opts) {
    let informationCollector = opts && 'informationCollector' in opts ? opts.informationCollector : null;
    if (!(image !== null)) dart.assertFailed(null, I[0], 767, 16, "image != null");
    image_stream.OneFrameImageStreamCompleter.__proto__.new.call(this);
    image.then(dart.void, dart.bind(this, 'setImage'), {onError: dart.fn((error, stack) => {
        this.reportError({context: new assertions.ErrorDescription.new("resolving a single-frame image stream"), exception: error, stack: stack, informationCollector: informationCollector, silent: true});
      }, T.ObjectAndStackTraceToNull())});
  }).prototype = image_stream.OneFrameImageStreamCompleter.prototype;
  dart.addTypeTests(image_stream.OneFrameImageStreamCompleter);
  dart.addTypeCaches(image_stream.OneFrameImageStreamCompleter);
  dart.setLibraryUri(image_stream.OneFrameImageStreamCompleter, I[1]);
  var _codec = dart.privateName(image_stream, "_codec");
  var _nextFrame = dart.privateName(image_stream, "_nextFrame");
  var __MultiFrameImageStreamCompleter__shownTimestamp = dart.privateName(image_stream, "_#MultiFrameImageStreamCompleter#_shownTimestamp");
  var _frameDuration = dart.privateName(image_stream, "_frameDuration");
  var _framesEmitted = dart.privateName(image_stream, "_framesEmitted");
  var _timer = dart.privateName(image_stream, "_timer");
  var _frameCallbackScheduled = dart.privateName(image_stream, "_frameCallbackScheduled");
  var _informationCollector = dart.privateName(image_stream, "_informationCollector");
  var _scale = dart.privateName(image_stream, "_scale");
  var _handleCodecReady = dart.privateName(image_stream, "_handleCodecReady");
  var _shownTimestamp = dart.privateName(image_stream, "_shownTimestamp");
  var _decodeNextFrameAndSchedule = dart.privateName(image_stream, "_decodeNextFrameAndSchedule");
  var _isFirstFrame = dart.privateName(image_stream, "_isFirstFrame");
  var _hasFrameDurationPassed = dart.privateName(image_stream, "_hasFrameDurationPassed");
  var _emitFrame = dart.privateName(image_stream, "_emitFrame");
  var _scheduleAppFrame = dart.privateName(image_stream, "_scheduleAppFrame");
  var _handleAppFrame = dart.privateName(image_stream, "_handleAppFrame");
  image_stream.MultiFrameImageStreamCompleter = class MultiFrameImageStreamCompleter extends image_stream.ImageStreamCompleter {
    get [_shownTimestamp]() {
      let t4;
      t4 = this[__MultiFrameImageStreamCompleter__shownTimestamp];
      return t4 == null ? dart.throw(new _internal.LateError.fieldNI("_shownTimestamp")) : t4;
    }
    set [_shownTimestamp](t4) {
      this[__MultiFrameImageStreamCompleter__shownTimestamp] = t4;
    }
    [_handleCodecReady](codec) {
      this[_codec] = codec;
      if (!(this[_codec] != null)) dart.assertFailed(null, I[0], 881, 12, "_codec != null");
      if (this.hasListeners) {
        this[_decodeNextFrameAndSchedule]();
      }
    }
    [_handleAppFrame](timestamp) {
      this[_frameCallbackScheduled] = false;
      if (!this.hasListeners) return;
      if (!(this[_nextFrame] != null)) dart.assertFailed(null, I[0], 892, 12, "_nextFrame != null");
      if (this[_isFirstFrame]() || this[_hasFrameDurationPassed](timestamp)) {
        this[_emitFrame](new image_stream.ImageInfo.new({image: dart.nullCheck(this[_nextFrame]).image.clone(), scale: this[_scale], debugLabel: this.debugLabel}));
        this[_shownTimestamp] = timestamp;
        this[_frameDuration] = dart.nullCheck(this[_nextFrame]).duration;
        dart.nullCheck(this[_nextFrame]).image.dispose();
        this[_nextFrame] = null;
        let completedCycles = (this[_framesEmitted] / dart.nullCheck(this[_codec]).frameCount)[$truncate]();
        if (dart.nullCheck(this[_codec]).repetitionCount === -1 || completedCycles <= dart.nullCheck(this[_codec]).repetitionCount) {
          this[_decodeNextFrameAndSchedule]();
        }
        return;
      }
      let delay = dart.nullCheck(this[_frameDuration])['-'](timestamp['-'](this[_shownTimestamp]));
      this[_timer] = async.Timer.new(delay['*'](binding.timeDilation), dart.fn(() => {
        this[_scheduleAppFrame]();
      }, T.VoidTovoid()));
    }
    [_isFirstFrame]() {
      return this[_frameDuration] == null;
    }
    [_hasFrameDurationPassed](timestamp) {
      return timestamp['-'](this[_shownTimestamp])['>='](dart.nullCheck(this[_frameDuration]));
    }
    [_decodeNextFrameAndSchedule]() {
      return async.async(dart.void, (function* _decodeNextFrameAndSchedule() {
        let t5;
        t5 = this[_nextFrame];
        t5 == null ? null : t5.image.dispose();
        this[_nextFrame] = null;
        try {
          this[_nextFrame] = (yield dart.nullCheck(this[_codec]).getNextFrame());
        } catch (e) {
          let exception = dart.getThrown(e);
          let stack = dart.stackTrace(e);
          if (core.Object.is(exception)) {
            this.reportError({context: new assertions.ErrorDescription.new("resolving an image frame"), exception: exception, stack: stack, informationCollector: this[_informationCollector], silent: true});
            return;
          } else
            throw e;
        }
        if (dart.nullCheck(this[_codec]).frameCount === 1) {
          if (!this.hasListeners) {
            return;
          }
          this[_emitFrame](new image_stream.ImageInfo.new({image: dart.nullCheck(this[_nextFrame]).image.clone(), scale: this[_scale], debugLabel: this.debugLabel}));
          dart.nullCheck(this[_nextFrame]).image.dispose();
          this[_nextFrame] = null;
          return;
        }
        this[_scheduleAppFrame]();
      }).bind(this));
    }
    [_scheduleAppFrame]() {
      if (this[_frameCallbackScheduled]) {
        return;
      }
      this[_frameCallbackScheduled] = true;
      dart.nullCheck(binding.SchedulerBinding.instance).scheduleFrameCallback(dart.bind(this, _handleAppFrame));
    }
    [_emitFrame](imageInfo) {
      this.setImage(imageInfo);
      this[_framesEmitted] = this[_framesEmitted] + 1;
    }
    addListener(listener) {
      if (!this.hasListeners && this[_codec] != null) this[_decodeNextFrameAndSchedule]();
      super.addListener(listener);
    }
    removeListener(listener) {
      let t6;
      super.removeListener(listener);
      if (!this.hasListeners) {
        t6 = this[_timer];
        t6 == null ? null : t6.cancel();
        this[_timer] = null;
      }
    }
  };
  (image_stream.MultiFrameImageStreamCompleter.new = function(opts) {
    let codec = opts && 'codec' in opts ? opts.codec : null;
    let scale = opts && 'scale' in opts ? opts.scale : null;
    let debugLabel = opts && 'debugLabel' in opts ? opts.debugLabel : null;
    let chunkEvents = opts && 'chunkEvents' in opts ? opts.chunkEvents : null;
    let informationCollector = opts && 'informationCollector' in opts ? opts.informationCollector : null;
    this[_codec] = null;
    this[_nextFrame] = null;
    this[__MultiFrameImageStreamCompleter__shownTimestamp] = null;
    this[_frameDuration] = null;
    this[_framesEmitted] = 0;
    this[_timer] = null;
    this[_frameCallbackScheduled] = false;
    if (!(codec !== null)) dart.assertFailed(null, I[0], 836, 15, "codec != null");
    this[_informationCollector] = informationCollector;
    this[_scale] = scale;
    image_stream.MultiFrameImageStreamCompleter.__proto__.new.call(this);
    this.debugLabel = debugLabel;
    codec.then(dart.void, dart.bind(this, _handleCodecReady), {onError: dart.fn((error, stack) => {
        this.reportError({context: new assertions.ErrorDescription.new("resolving an image codec"), exception: error, stack: stack, informationCollector: informationCollector, silent: true});
      }, T.ObjectAndStackTraceToNull())});
    if (chunkEvents != null) {
      chunkEvents.listen(dart.bind(this, 'reportImageChunkEvent'), {onError: dart.fn((error, stack) => {
          this.reportError({context: new assertions.ErrorDescription.new("loading an image"), exception: error, stack: stack, informationCollector: informationCollector, silent: true});
        }, T.ObjectAndStackTraceToNull())});
    }
  }).prototype = image_stream.MultiFrameImageStreamCompleter.prototype;
  dart.addTypeTests(image_stream.MultiFrameImageStreamCompleter);
  dart.addTypeCaches(image_stream.MultiFrameImageStreamCompleter);
  dart.setMethodSignature(image_stream.MultiFrameImageStreamCompleter, () => ({
    __proto__: dart.getMethods(image_stream.MultiFrameImageStreamCompleter.__proto__),
    [_handleCodecReady]: dart.fnType(dart.void, [ui.Codec]),
    [_handleAppFrame]: dart.fnType(dart.void, [core.Duration]),
    [_isFirstFrame]: dart.fnType(core.bool, []),
    [_hasFrameDurationPassed]: dart.fnType(core.bool, [core.Duration]),
    [_decodeNextFrameAndSchedule]: dart.fnType(async.Future$(dart.void), []),
    [_scheduleAppFrame]: dart.fnType(dart.void, []),
    [_emitFrame]: dart.fnType(dart.void, [image_stream.ImageInfo])
  }));
  dart.setGetterSignature(image_stream.MultiFrameImageStreamCompleter, () => ({
    __proto__: dart.getGetters(image_stream.MultiFrameImageStreamCompleter.__proto__),
    [_shownTimestamp]: core.Duration
  }));
  dart.setSetterSignature(image_stream.MultiFrameImageStreamCompleter, () => ({
    __proto__: dart.getSetters(image_stream.MultiFrameImageStreamCompleter.__proto__),
    [_shownTimestamp]: core.Duration
  }));
  dart.setLibraryUri(image_stream.MultiFrameImageStreamCompleter, I[1]);
  dart.setFieldSignature(image_stream.MultiFrameImageStreamCompleter, () => ({
    __proto__: dart.getFields(image_stream.MultiFrameImageStreamCompleter.__proto__),
    [_codec]: dart.fieldType(dart.nullable(ui.Codec)),
    [_scale]: dart.finalFieldType(core.double),
    [_informationCollector]: dart.finalFieldType(dart.nullable(dart.fnType(core.Iterable$(diagnostics.DiagnosticsNode), []))),
    [_nextFrame]: dart.fieldType(dart.nullable(ui.FrameInfo)),
    [__MultiFrameImageStreamCompleter__shownTimestamp]: dart.fieldType(dart.nullable(core.Duration)),
    [_frameDuration]: dart.fieldType(dart.nullable(core.Duration)),
    [_framesEmitted]: dart.fieldType(core.int),
    [_timer]: dart.fieldType(dart.nullable(async.Timer)),
    [_frameCallbackScheduled]: dart.fieldType(core.bool)
  }));
  dart.trackLibraries("packages/flutter/src/painting/image_stream.dart", {
    "package:flutter/src/painting/image_stream.dart": image_stream
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["image_stream.dart"],"names":[],"mappings":"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","file":"../../../../../../packages/flutter/src/painting/image_stream.dart.lib.js"}');
  // Exports:
  return {
    src__painting__image_stream: image_stream
  };
}));

//# sourceMappingURL=image_stream.dart.lib.js.map
>>>>>>> feature-b
